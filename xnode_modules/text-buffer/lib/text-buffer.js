(function() {
  var BufferOffsetIndex, ChangeEvent, CompositeDisposable, DefaultHistoryProvider, DisplayLayer, Disposable, Emitter, File, Grim, MarkerLayer, MatchIterator, NativeTextBuffer, Patch, Point, Range, TextBuffer, TransactionAbortedError, _, crypto, debounce, diff, extentForText, fs, mkdirp, newlineRegex, normalizePatchChanges, patchFromChanges, path, ref, ref1, ref2, ref3, regexIsSingleLine, spliceArray, traversal, traverse,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  ref = require('event-kit'), Emitter = ref.Emitter, CompositeDisposable = ref.CompositeDisposable, Disposable = ref.Disposable;

  File = require('pathwatcher').File;

  diff = require('diff');

  _ = require('underscore-plus');

  fs = require('fs-plus');

  path = require('path');

  crypto = require('crypto');

  mkdirp = require('mkdirp');

  ref1 = require('superstring'), BufferOffsetIndex = ref1.BufferOffsetIndex, Patch = ref1.Patch, NativeTextBuffer = ref1.TextBuffer;

  Point = require('./point');

  Range = require('./range');

  DefaultHistoryProvider = require('./default-history-provider');

  MarkerLayer = require('./marker-layer');

  MatchIterator = require('./match-iterator');

  DisplayLayer = require('./display-layer');

  ref2 = require('./helpers'), spliceArray = ref2.spliceArray, newlineRegex = ref2.newlineRegex, patchFromChanges = ref2.patchFromChanges, normalizePatchChanges = ref2.normalizePatchChanges, regexIsSingleLine = ref2.regexIsSingleLine, extentForText = ref2.extentForText, debounce = ref2.debounce;

  ref3 = require('./point-helpers'), traverse = ref3.traverse, traversal = ref3.traversal;

  Grim = require('grim');

  TransactionAbortedError = (function(superClass) {
    extend(TransactionAbortedError, superClass);

    function TransactionAbortedError() {
      TransactionAbortedError.__super__.constructor.apply(this, arguments);
    }

    return TransactionAbortedError;

  })(Error);

  ChangeEvent = (function() {
    function ChangeEvent(buffer, changes) {
      var newEnd, newText, oldEnd, oldText, start;
      this.changes = Object.freeze(normalizePatchChanges(changes));
      start = changes[0].oldStart;
      oldEnd = changes[changes.length - 1].oldEnd;
      newEnd = changes[changes.length - 1].newEnd;
      this.oldRange = new Range(start, oldEnd).freeze();
      this.newRange = new Range(start, newEnd).freeze();
      oldText = null;
      newText = null;
      Object.defineProperty(this, 'oldText', {
        enumerable: false,
        get: function() {
          var change, j, oldBuffer;
          if (oldText == null) {
            oldBuffer = new NativeTextBuffer(this.newText);
            for (j = changes.length - 1; j >= 0; j += -1) {
              change = changes[j];
              oldBuffer.setTextInRange(new Range(traversal(change.newStart, start), traversal(change.newEnd, start)), change.oldText);
            }
            oldText = oldBuffer.getText();
          }
          return oldText;
        }
      });
      Object.defineProperty(this, 'newText', {
        enumerable: false,
        get: function() {
          if (newText == null) {
            newText = buffer.getTextInRange(this.newRange);
          }
          return newText;
        }
      });
    }

    ChangeEvent.prototype.isEqual = function(other) {
      return this.changes.length === other.changes.length && this.changes.every(function(change, i) {
        return change.isEqual(other.changes[i]);
      }) && this.oldRange.isEqual(other.oldRange) && this.newRange.isEqual(other.newRange);
    };

    return ChangeEvent;

  })();

  module.exports = TextBuffer = (function() {
    TextBuffer.version = 5;

    TextBuffer.Point = Point;

    TextBuffer.Range = Range;

    TextBuffer.newlineRegex = newlineRegex;

    TextBuffer.prototype.encoding = null;

    TextBuffer.prototype.stoppedChangingDelay = 300;

    TextBuffer.prototype.fileChangeDelay = 200;

    TextBuffer.prototype.stoppedChangingTimeout = null;

    TextBuffer.prototype.conflict = false;

    TextBuffer.prototype.file = null;

    TextBuffer.prototype.refcount = 0;

    TextBuffer.prototype.fileSubscriptions = null;

    TextBuffer.prototype.backwardsScanChunkSize = 8000;

    TextBuffer.prototype.defaultMaxUndoEntries = 10000;

    TextBuffer.prototype.nextMarkerLayerId = 0;

    Object.defineProperty(TextBuffer, 'history', {
      enumerable: false,
      get: function() {
        return this.historyProvider;
      }
    });


    /*
    Section: Construction
     */

    function TextBuffer(params) {
      var ref4, ref5, text;
      text = typeof params === 'string' ? params : params != null ? params.text : void 0;
      this.emitter = new Emitter;
      this.changesSinceLastStoppedChangingEvent = [];
      this.changesSinceLastDidChangeTextEvent = [];
      this.id = crypto.randomBytes(16).toString('hex');
      this.buffer = new NativeTextBuffer(text);
      this.debouncedEmitDidStopChangingEvent = debounce(this.emitDidStopChangingEvent.bind(this), this.stoppedChangingDelay);
      this.textDecorationLayers = new Set();
      this.maxUndoEntries = (ref4 = params != null ? params.maxUndoEntries : void 0) != null ? ref4 : this.defaultMaxUndoEntries;
      this.setHistoryProvider(new DefaultHistoryProvider(this));
      this.nextMarkerLayerId = 0;
      this.nextDisplayLayerId = 0;
      this.defaultMarkerLayer = new MarkerLayer(this, String(this.nextMarkerLayerId++));
      this.displayLayers = {};
      this.markerLayers = {};
      this.markerLayers[this.defaultMarkerLayer.id] = this.defaultMarkerLayer;
      this.markerLayersWithPendingUpdateEvents = new Set();
      this.nextMarkerId = 1;
      this.outstandingSaveCount = 0;
      this.loadCount = 0;
      this._emittedWillChangeEvent = false;
      this.setEncoding(params != null ? params.encoding : void 0);
      this.setPreferredLineEnding(params != null ? params.preferredLineEnding : void 0);
      this.loaded = false;
      this.destroyed = false;
      this.transactCallDepth = 0;
      this.digestWhenLastPersisted = false;
      this.shouldDestroyOnFileDelete = (ref5 = params != null ? params.shouldDestroyOnFileDelete : void 0) != null ? ref5 : function() {
        return false;
      };
      if (params != null ? params.filePath : void 0) {
        this.setPath(params.filePath);
        if (params != null ? params.load : void 0) {
          Grim.deprecate('The `load` option to the TextBuffer constructor is deprecated. ' + 'Get a loaded buffer using TextBuffer.load(filePath) instead.');
          this.load({
            internal: true
          });
        }
      }
    }

    TextBuffer.prototype.toString = function() {
      return "<TextBuffer " + this.id + ">";
    };

    TextBuffer.load = function(source, params) {
      var buffer;
      buffer = new TextBuffer(params);
      if (typeof source === 'string') {
        buffer.setPath(source);
      } else {
        buffer.setFile(source);
      }
      return buffer.load({
        clearHistory: true,
        internal: true,
        mustExist: params != null ? params.mustExist : void 0
      }).then(function() {
        return buffer;
      })["catch"](function(err) {
        buffer.destroy();
        throw err;
      });
    };

    TextBuffer.loadSync = function(filePath, params) {
      var buffer, e, error1;
      buffer = new TextBuffer(params);
      buffer.setPath(filePath);
      try {
        buffer.loadSync({
          internal: true,
          mustExist: params != null ? params.mustExist : void 0
        });
      } catch (error1) {
        e = error1;
        buffer.destroy();
        throw e;
      }
      return buffer;
    };

    TextBuffer.deserialize = function(params) {
      var promise;
      if (params.version !== TextBuffer.prototype.version) {
        return;
      }
      delete params.load;
      if (params.filePath != null) {
        promise = this.load(params.filePath, params).then(function(buffer) {
          if (typeof params.text === 'string') {
            buffer.setText(params.text);
          } else if (buffer.digestWhenLastPersisted === params.digestWhenLastPersisted) {
            buffer.buffer.deserializeChanges(params.outstandingChanges);
          } else {
            params.history = {};
          }
          return buffer;
        });
      } else {
        promise = Promise.resolve(new TextBuffer(params));
      }
      return promise.then(function(buffer) {
        var layer, layerId, layerState, ref4, ref5;
        buffer.id = params.id;
        buffer.preferredLineEnding = params.preferredLineEnding;
        buffer.nextMarkerId = params.nextMarkerId;
        buffer.nextMarkerLayerId = params.nextMarkerLayerId;
        buffer.nextDisplayLayerId = params.nextDisplayLayerId;
        buffer.historyProvider.deserialize(params.history, buffer);
        ref4 = params.markerLayers;
        for (layerId in ref4) {
          layerState = ref4[layerId];
          if (layerId === params.defaultMarkerLayerId) {
            buffer.defaultMarkerLayer.id = layerId;
            buffer.defaultMarkerLayer.deserialize(layerState);
            layer = buffer.defaultMarkerLayer;
          } else {
            layer = MarkerLayer.deserialize(buffer, layerState);
          }
          buffer.markerLayers[layerId] = layer;
        }
        ref5 = params.displayLayers;
        for (layerId in ref5) {
          layerState = ref5[layerId];
          buffer.displayLayers[layerId] = DisplayLayer.deserialize(buffer, layerState);
        }
        return buffer;
      });
    };

    TextBuffer.prototype.getId = function() {
      return this.id;
    };

    TextBuffer.prototype.serialize = function(options) {
      var displayLayers, filePath, history, id, layer, markerLayers, ref4, ref5, result;
      if (options == null) {
        options = {};
      }
      if (options.markerLayers == null) {
        options.markerLayers = true;
      }
      if (options.history == null) {
        options.history = true;
      }
      markerLayers = {};
      if (options.markerLayers) {
        ref4 = this.markerLayers;
        for (id in ref4) {
          layer = ref4[id];
          if (layer.persistent) {
            markerLayers[id] = layer.serialize();
          }
        }
      }
      displayLayers = {};
      ref5 = this.displayLayers;
      for (id in ref5) {
        layer = ref5[id];
        displayLayers[id] = layer.serialize();
      }
      history = {};
      if (options.history) {
        history = this.historyProvider.serialize(options);
      }
      result = {
        id: this.getId(),
        defaultMarkerLayerId: this.defaultMarkerLayer.id,
        markerLayers: markerLayers,
        displayLayers: displayLayers,
        nextMarkerLayerId: this.nextMarkerLayerId,
        nextDisplayLayerId: this.nextDisplayLayerId,
        history: history,
        encoding: this.getEncoding(),
        preferredLineEnding: this.preferredLineEnding,
        nextMarkerId: this.nextMarkerId
      };
      if (filePath = this.getPath()) {
        if (this.baseTextDigestCache == null) {
          this.baseTextDigestCache = this.buffer.baseTextDigest();
        }
        result.filePath = filePath;
        result.digestWhenLastPersisted = this.digestWhenLastPersisted;
        result.outstandingChanges = this.buffer.serializeChanges();
      } else {
        result.text = this.getText();
      }
      return result;
    };


    /*
    Section: Event Subscription
     */

    TextBuffer.prototype.onWillChange = function(callback) {
      return this.emitter.on('will-change', callback);
    };

    TextBuffer.prototype.onDidChange = function(callback) {
      return this.emitter.on('did-change-text', callback);
    };

    TextBuffer.prototype.onDidChangeText = function(callback) {
      return this.onDidChange(callback);
    };

    TextBuffer.prototype.onDidStopChanging = function(callback) {
      return this.emitter.on('did-stop-changing', callback);
    };

    TextBuffer.prototype.onDidConflict = function(callback) {
      return this.emitter.on('did-conflict', callback);
    };

    TextBuffer.prototype.onDidChangeModified = function(callback) {
      return this.emitter.on('did-change-modified', callback);
    };

    TextBuffer.prototype.onDidUpdateMarkers = function(callback) {
      return this.emitter.on('did-update-markers', callback);
    };

    TextBuffer.prototype.onDidCreateMarker = function(callback) {
      return this.emitter.on('did-create-marker', callback);
    };

    TextBuffer.prototype.onDidChangePath = function(callback) {
      return this.emitter.on('did-change-path', callback);
    };

    TextBuffer.prototype.onDidChangeEncoding = function(callback) {
      return this.emitter.on('did-change-encoding', callback);
    };

    TextBuffer.prototype.onWillSave = function(callback) {
      return this.emitter.on('will-save', callback);
    };

    TextBuffer.prototype.onDidSave = function(callback) {
      return this.emitter.on('did-save', callback);
    };

    TextBuffer.prototype.onDidDelete = function(callback) {
      return this.emitter.on('did-delete', callback);
    };

    TextBuffer.prototype.onWillReload = function(callback) {
      return this.emitter.on('will-reload', callback);
    };

    TextBuffer.prototype.onDidReload = function(callback) {
      return this.emitter.on('did-reload', callback);
    };

    TextBuffer.prototype.onDidDestroy = function(callback) {
      return this.emitter.on('did-destroy', callback);
    };

    TextBuffer.prototype.onWillThrowWatchError = function(callback) {
      return this.emitter.on('will-throw-watch-error', callback);
    };

    TextBuffer.prototype.getStoppedChangingDelay = function() {
      return this.stoppedChangingDelay;
    };


    /*
    Section: File Details
     */

    TextBuffer.prototype.isModified = function() {
      if (this.file != null) {
        return !this.file.existsSync() || this.buffer.isModified();
      } else {
        return this.buffer.getLength() > 0;
      }
    };

    TextBuffer.prototype.isInConflict = function() {
      return this.isModified() && this.fileHasChangedSinceLastLoad;
    };

    TextBuffer.prototype.getPath = function() {
      var ref4;
      return (ref4 = this.file) != null ? ref4.getPath() : void 0;
    };

    TextBuffer.prototype.setPath = function(filePath) {
      if (filePath === this.getPath()) {
        return;
      }
      return this.setFile(filePath ? new File(filePath) : void 0);
    };

    TextBuffer.prototype.setFile = function(file) {
      var base;
      if ((file != null ? file.getPath() : void 0) === this.getPath()) {
        return;
      }
      this.file = file;
      if (this.file != null) {
        if (typeof (base = this.file).setEncoding === "function") {
          base.setEncoding(this.getEncoding());
        }
        this.subscribeToFile();
      }
      return this.emitter.emit('did-change-path', this.getPath());
    };

    TextBuffer.prototype.setEncoding = function(encoding) {
      var base;
      if (encoding == null) {
        encoding = 'utf8';
      }
      if (encoding === this.getEncoding()) {
        return;
      }
      this.encoding = encoding;
      if (this.file != null) {
        if (typeof (base = this.file).setEncoding === "function") {
          base.setEncoding(encoding);
        }
        this.emitter.emit('did-change-encoding', encoding);
        if (!this.isModified()) {
          this.load({
            clearHistory: true,
            internal: true
          });
        }
      } else {
        this.emitter.emit('did-change-encoding', encoding);
      }
    };

    TextBuffer.prototype.getEncoding = function() {
      var ref4, ref5;
      return (ref4 = this.encoding) != null ? ref4 : (ref5 = this.file) != null ? ref5.getEncoding() : void 0;
    };

    TextBuffer.prototype.setPreferredLineEnding = function(preferredLineEnding) {
      if (preferredLineEnding == null) {
        preferredLineEnding = null;
      }
      return this.preferredLineEnding = preferredLineEnding;
    };

    TextBuffer.prototype.getPreferredLineEnding = function() {
      return this.preferredLineEnding;
    };

    TextBuffer.prototype.getUri = function() {
      return this.getPath();
    };

    TextBuffer.prototype.getBaseName = function() {
      var ref4;
      return (ref4 = this.file) != null ? ref4.getBaseName() : void 0;
    };


    /*
    Section: Reading Text
     */

    TextBuffer.prototype.isEmpty = function() {
      return this.buffer.getLength() === 0;
    };

    TextBuffer.prototype.getText = function() {
      return this.cachedText != null ? this.cachedText : this.cachedText = this.buffer.getText();
    };

    TextBuffer.prototype.getTextInRange = function(range) {
      return this.buffer.getTextInRange(Range.fromObject(range));
    };

    TextBuffer.prototype.getLines = function() {
      return this.buffer.getLines();
    };

    TextBuffer.prototype.getLastLine = function() {
      return this.lineForRow(this.getLastRow());
    };

    TextBuffer.prototype.lineForRow = function(row) {
      return this.buffer.lineForRow(row);
    };

    TextBuffer.prototype.lineEndingForRow = function(row) {
      return this.buffer.lineEndingForRow(row);
    };

    TextBuffer.prototype.lineLengthForRow = function(row) {
      return this.buffer.lineLengthForRow(row);
    };

    TextBuffer.prototype.isRowBlank = function(row) {
      return !/\S/.test(this.lineForRow(row));
    };

    TextBuffer.prototype.previousNonBlankRow = function(startRow) {
      var j, ref4, row;
      if (startRow === 0) {
        return null;
      }
      startRow = Math.min(startRow, this.getLastRow());
      for (row = j = ref4 = startRow - 1; ref4 <= 0 ? j <= 0 : j >= 0; row = ref4 <= 0 ? ++j : --j) {
        if (!this.isRowBlank(row)) {
          return row;
        }
      }
      return null;
    };

    TextBuffer.prototype.nextNonBlankRow = function(startRow) {
      var j, lastRow, ref4, ref5, row;
      lastRow = this.getLastRow();
      if (startRow < lastRow) {
        for (row = j = ref4 = startRow + 1, ref5 = lastRow; ref4 <= ref5 ? j <= ref5 : j >= ref5; row = ref4 <= ref5 ? ++j : --j) {
          if (!this.isRowBlank(row)) {
            return row;
          }
        }
      }
      return null;
    };


    /*
    Section: Mutating Text
     */

    TextBuffer.prototype.setText = function(text) {
      return this.setTextInRange(this.getRange(), text, {
        normalizeLineEndings: false
      });
    };

    TextBuffer.prototype.setTextViaDiff = function(text) {
      var computeBufferColumn, currentText;
      currentText = this.getText();
      if (currentText === text) {
        return;
      }
      computeBufferColumn = function(str) {
        var newlineIndex;
        newlineIndex = str.lastIndexOf('\n');
        if (newlineIndex === -1) {
          return str.length;
        } else {
          return str.length - newlineIndex - 1;
        }
      };
      return this.transact((function(_this) {
        return function() {
          var change, changeOptions, column, currentPosition, endColumn, endRow, j, len, lineCount, lineDiff, row;
          row = 0;
          column = 0;
          currentPosition = [0, 0];
          lineDiff = diff.diffLines(currentText, text);
          changeOptions = {
            normalizeLineEndings: false
          };
          for (j = 0, len = lineDiff.length; j < len; j++) {
            change = lineDiff[j];
            lineCount = change.count;
            currentPosition[0] = row;
            currentPosition[1] = column;
            if (change.added) {
              row += lineCount;
              column = computeBufferColumn(change.value);
              _this.setTextInRange([currentPosition, currentPosition], change.value, changeOptions);
            } else if (change.removed) {
              endRow = row + lineCount;
              endColumn = column + computeBufferColumn(change.value);
              _this.setTextInRange([currentPosition, [endRow, endColumn]], '', changeOptions);
            } else {
              row += lineCount;
              column = computeBufferColumn(change.value);
            }
          }
        };
      })(this));
    };

    TextBuffer.prototype.setTextInRange = function(range, newText, options) {
      var change, newRange, normalizeLineEndings, normalizedEnding, oldRange, oldText, undo;
      if (options != null) {
        normalizeLineEndings = options.normalizeLineEndings, undo = options.undo;
      }
      if (normalizeLineEndings == null) {
        normalizeLineEndings = true;
      }
      if (this.transactCallDepth === 0 && undo !== 'skip') {
        return this.transact((function(_this) {
          return function() {
            return _this.setTextInRange(range, newText, options);
          };
        })(this));
      }
      oldRange = this.clipRange(range);
      oldText = this.getTextInRange(oldRange);
      if (normalizeLineEndings) {
        normalizedEnding = this.preferredLineEnding || this.lineEndingForRow(oldRange.start.row) || this.lineEndingForRow(oldRange.start.row - 1);
        if (normalizedEnding) {
          newText = newText.replace(newlineRegex, normalizedEnding);
        }
      }
      change = {
        oldStart: oldRange.start,
        oldEnd: oldRange.end,
        newStart: oldRange.start,
        newEnd: traverse(oldRange.start, extentForText(newText)),
        oldText: oldText,
        newText: newText
      };
      newRange = this.applyChange(change, undo !== 'skip');
      if (this.transactCallDepth === 0 && undo === 'skip') {
        this.emitDidChangeTextEvent();
        this.emitMarkerChangeEvents();
      }
      return newRange;
    };

    TextBuffer.prototype.insert = function(position, text, options) {
      return this.setTextInRange(new Range(position, position), text, options);
    };

    TextBuffer.prototype.append = function(text, options) {
      return this.insert(this.getEndPosition(), text, options);
    };

    TextBuffer.prototype.applyChange = function(change, pushToHistory) {
      var changeEvent, displayLayer, id, markerLayer, newEnd, newExtent, newRange, newStart, newText, oldEnd, oldExtent, oldRange, oldStart, oldText, ref4, ref5, ref6;
      if (pushToHistory == null) {
        pushToHistory = false;
      }
      newStart = change.newStart, newEnd = change.newEnd, oldStart = change.oldStart, oldEnd = change.oldEnd, oldText = change.oldText, newText = change.newText;
      oldExtent = traversal(oldEnd, oldStart);
      oldRange = Range(newStart, traverse(newStart, oldExtent));
      oldRange.freeze();
      newExtent = traversal(newEnd, newStart);
      newRange = Range(newStart, traverse(newStart, newExtent));
      newRange.freeze();
      if (pushToHistory) {
        if (change.oldExtent == null) {
          change.oldExtent = oldExtent;
        }
        if (change.newExtent == null) {
          change.newExtent = newExtent;
        }
        if ((ref4 = this.historyProvider) != null) {
          ref4.pushChange(change);
        }
      }
      changeEvent = {
        oldRange: oldRange,
        newRange: newRange,
        oldText: oldText,
        newText: newText
      };
      ref5 = this.displayLayers;
      for (id in ref5) {
        displayLayer = ref5[id];
        displayLayer.bufferWillChange(changeEvent);
      }
      this.emitWillChangeEvent();
      this.buffer.setTextInRange(oldRange, newText);
      if (this.markerLayers != null) {
        ref6 = this.markerLayers;
        for (id in ref6) {
          markerLayer = ref6[id];
          markerLayer.splice(oldRange.start, oldExtent, newExtent);
          this.markerLayersWithPendingUpdateEvents.add(markerLayer);
        }
      }
      this.cachedText = null;
      this.changesSinceLastDidChangeTextEvent.push(change);
      this.changesSinceLastStoppedChangingEvent.push(change);
      this.emitDidChangeEvent(changeEvent);
      return newRange;
    };

    TextBuffer.prototype.emitDidChangeEvent = function(changeEvent) {
      var displayLayer, event, id, ref4;
      this.textDecorationLayers.forEach(function(textDecorationLayer) {
        return textDecorationLayer.bufferDidChange(changeEvent);
      });
      ref4 = this.displayLayers;
      for (id in ref4) {
        displayLayer = ref4[id];
        event = displayLayer.bufferDidChange(changeEvent);
      }
    };

    TextBuffer.prototype["delete"] = function(range) {
      return this.setTextInRange(range, '');
    };

    TextBuffer.prototype.deleteRow = function(row) {
      return this.deleteRows(row, row);
    };

    TextBuffer.prototype.deleteRows = function(startRow, endRow) {
      var endPoint, lastRow, ref4, startPoint;
      lastRow = this.getLastRow();
      if (startRow > endRow) {
        ref4 = [endRow, startRow], startRow = ref4[0], endRow = ref4[1];
      }
      if (endRow < 0) {
        return new Range(this.getFirstPosition(), this.getFirstPosition());
      }
      if (startRow > lastRow) {
        return new Range(this.getEndPosition(), this.getEndPosition());
      }
      startRow = Math.max(0, startRow);
      endRow = Math.min(lastRow, endRow);
      if (endRow < lastRow) {
        startPoint = new Point(startRow, 0);
        endPoint = new Point(endRow + 1, 0);
      } else {
        if (startRow === 0) {
          startPoint = new Point(startRow, 0);
        } else {
          startPoint = new Point(startRow - 1, this.lineLengthForRow(startRow - 1));
        }
        endPoint = new Point(endRow, this.lineLengthForRow(endRow));
      }
      return this["delete"](new Range(startPoint, endPoint));
    };


    /*
    Section: Markers
     */

    TextBuffer.prototype.addMarkerLayer = function(options) {
      var layer;
      layer = new MarkerLayer(this, String(this.nextMarkerLayerId++), options);
      this.markerLayers[layer.id] = layer;
      return layer;
    };

    TextBuffer.prototype.getMarkerLayer = function(id) {
      return this.markerLayers[id];
    };

    TextBuffer.prototype.getDefaultMarkerLayer = function() {
      return this.defaultMarkerLayer;
    };

    TextBuffer.prototype.markRange = function(range, properties) {
      return this.defaultMarkerLayer.markRange(range, properties);
    };

    TextBuffer.prototype.markPosition = function(position, options) {
      return this.defaultMarkerLayer.markPosition(position, options);
    };

    TextBuffer.prototype.getMarkers = function() {
      return this.defaultMarkerLayer.getMarkers();
    };

    TextBuffer.prototype.getMarker = function(id) {
      return this.defaultMarkerLayer.getMarker(id);
    };

    TextBuffer.prototype.findMarkers = function(params) {
      return this.defaultMarkerLayer.findMarkers(params);
    };

    TextBuffer.prototype.getMarkerCount = function() {
      return this.defaultMarkerLayer.getMarkerCount();
    };

    TextBuffer.prototype.destroyMarker = function(id) {
      var ref4;
      return (ref4 = this.getMarker(id)) != null ? ref4.destroy() : void 0;
    };


    /*
    Section: History
     */

    TextBuffer.prototype.setHistoryProvider = function(historyProvider) {
      return this.historyProvider = historyProvider;
    };

    TextBuffer.prototype.restoreDefaultHistoryProvider = function(history) {
      var provider;
      provider = new DefaultHistoryProvider(this);
      provider.restoreFromSnapshot(history);
      return this.setHistoryProvider(provider);
    };

    TextBuffer.prototype.getHistory = function(maxEntries) {
      var baseTextBuffer, change, j, newRange, ref4, snapshot;
      if (this.transactCallDepth > 0) {
        throw new Error('Cannot build history snapshots within transactions');
      }
      snapshot = this.historyProvider.getSnapshot(maxEntries);
      baseTextBuffer = new NativeTextBuffer(this.getText());
      ref4 = snapshot.undoStackChanges;
      for (j = ref4.length - 1; j >= 0; j += -1) {
        change = ref4[j];
        newRange = Range(change.newStart, change.newEnd);
        baseTextBuffer.setTextInRange(newRange, change.oldText);
      }
      return {
        baseText: baseTextBuffer.getText(),
        undoStack: snapshot.undoStack,
        redoStack: snapshot.redoStack,
        nextCheckpointId: snapshot.nextCheckpointId
      };
    };

    TextBuffer.prototype.undo = function() {
      var change, j, len, pop, ref4;
      if (pop = this.historyProvider.undo()) {
        this.emitWillChangeEvent();
        this.transactCallDepth++;
        try {
          ref4 = pop.textUpdates;
          for (j = 0, len = ref4.length; j < len; j++) {
            change = ref4[j];
            this.applyChange(change);
          }
        } finally {
          this.transactCallDepth--;
        }
        this.restoreFromMarkerSnapshot(pop.markers);
        this.emitDidChangeTextEvent();
        this.emitMarkerChangeEvents(pop.markers);
        return true;
      } else {
        return false;
      }
    };

    TextBuffer.prototype.redo = function() {
      var change, j, len, pop, ref4;
      if (pop = this.historyProvider.redo()) {
        this.emitWillChangeEvent();
        this.transactCallDepth++;
        try {
          ref4 = pop.textUpdates;
          for (j = 0, len = ref4.length; j < len; j++) {
            change = ref4[j];
            this.applyChange(change);
          }
        } finally {
          this.transactCallDepth--;
        }
        this.restoreFromMarkerSnapshot(pop.markers);
        this.emitDidChangeTextEvent();
        this.emitMarkerChangeEvents(pop.markers);
        return true;
      } else {
        return false;
      }
    };

    TextBuffer.prototype.transact = function(groupingInterval, fn) {
      var checkpointBefore, endMarkerSnapshot, error1, exception, result;
      if (typeof groupingInterval === 'function') {
        fn = groupingInterval;
        groupingInterval = 0;
      }
      checkpointBefore = this.historyProvider.createCheckpoint({
        markers: this.createMarkerSnapshot(),
        isBarrier: true
      });
      try {
        this.transactCallDepth++;
        result = fn();
      } catch (error1) {
        exception = error1;
        this.revertToCheckpoint(checkpointBefore, {
          deleteCheckpoint: true
        });
        if (!(exception instanceof TransactionAbortedError)) {
          throw exception;
        }
        return;
      } finally {
        this.transactCallDepth--;
      }
      if (this.isDestroyed()) {
        return result;
      }
      endMarkerSnapshot = this.createMarkerSnapshot();
      this.historyProvider.groupChangesSinceCheckpoint(checkpointBefore, {
        markers: endMarkerSnapshot,
        deleteCheckpoint: true
      });
      this.historyProvider.applyGroupingInterval(groupingInterval);
      this.historyProvider.enforceUndoStackSizeLimit();
      this.emitDidChangeTextEvent();
      this.emitMarkerChangeEvents(endMarkerSnapshot);
      return result;
    };

    TextBuffer.prototype.abortTransaction = function() {
      throw new TransactionAbortedError("Transaction aborted.");
    };

    TextBuffer.prototype.clearUndoStack = function() {
      return this.historyProvider.clearUndoStack();
    };

    TextBuffer.prototype.createCheckpoint = function() {
      return this.historyProvider.createCheckpoint({
        markers: this.createMarkerSnapshot(),
        isBarrier: false
      });
    };

    TextBuffer.prototype.revertToCheckpoint = function(checkpoint, options) {
      var change, j, len, ref4, truncated;
      if (truncated = this.historyProvider.revertToCheckpoint(checkpoint, options)) {
        this.emitWillChangeEvent();
        this.transactCallDepth++;
        try {
          ref4 = truncated.textUpdates;
          for (j = 0, len = ref4.length; j < len; j++) {
            change = ref4[j];
            this.applyChange(change);
          }
        } finally {
          this.transactCallDepth--;
        }
        this.restoreFromMarkerSnapshot(truncated.markers);
        this.emitDidChangeTextEvent();
        this.emitter.emit('did-update-markers');
        this.emitMarkerChangeEvents(truncated.markers);
        return true;
      } else {
        return false;
      }
    };

    TextBuffer.prototype.groupChangesSinceCheckpoint = function(checkpoint) {
      return this.historyProvider.groupChangesSinceCheckpoint(checkpoint, {
        markers: this.createMarkerSnapshot(),
        deleteCheckpoint: false
      });
    };

    TextBuffer.prototype.getChangesSinceCheckpoint = function(checkpoint) {
      var changes;
      if (changes = this.historyProvider.getChangesSinceCheckpoint(checkpoint)) {
        return normalizePatchChanges(changes);
      } else {
        return [];
      }
    };


    /*
    Section: Search And Replace
     */

    TextBuffer.prototype.scan = function(regex, options, iterator) {
      if (options == null) {
        options = {};
      }
      if (_.isFunction(options)) {
        iterator = options;
        options = {};
      }
      return this.scanInRange(regex, this.getRange(), options, iterator);
    };

    TextBuffer.prototype.backwardsScan = function(regex, options, iterator) {
      if (options == null) {
        options = {};
      }
      if (_.isFunction(options)) {
        iterator = options;
        options = {};
      }
      return this.backwardsScanInRange(regex, this.getRange(), options, iterator);
    };

    TextBuffer.prototype.scanInRange = function(regex, range, options, callback, reverse) {
      var flags, global, iterator;
      if (options == null) {
        options = {};
      }
      if (reverse == null) {
        reverse = false;
      }
      if (_.isFunction(options)) {
        reverse = callback;
        callback = options;
        options = {};
      }
      range = this.clipRange(range);
      global = regex.global;
      flags = "gm";
      if (regex.ignoreCase) {
        flags += "i";
      }
      regex = new RegExp(regex.source, flags);
      if (regexIsSingleLine(regex)) {
        if (reverse) {
          iterator = new MatchIterator.BackwardsSingleLine(this, regex, range, options);
        } else {
          iterator = new MatchIterator.ForwardsSingleLine(this, regex, range, options);
        }
      } else {
        if (reverse) {
          iterator = new MatchIterator.BackwardsMultiLine(this, regex, range, this.backwardsScanChunkSize, options);
        } else {
          iterator = new MatchIterator.ForwardsMultiLine(this, regex, range, options);
        }
      }
      return iterator.iterate(callback, global);
    };

    TextBuffer.prototype.backwardsScanInRange = function(regex, range, options, iterator) {
      if (options == null) {
        options = {};
      }
      if (_.isFunction(options)) {
        iterator = options;
        options = {};
      }
      return this.scanInRange(regex, range, options, iterator, true);
    };

    TextBuffer.prototype.replace = function(regex, replacementText) {
      var doSave, replacements;
      doSave = !this.isModified();
      replacements = 0;
      this.transact((function(_this) {
        return function() {
          return _this.scan(regex, function(arg) {
            var matchText, replace;
            matchText = arg.matchText, replace = arg.replace;
            replace(matchText.replace(regex, replacementText));
            return replacements++;
          });
        };
      })(this));
      if (doSave) {
        this.save();
      }
      return replacements;
    };

    TextBuffer.prototype.find = function(regex) {
      return this.buffer.find(regex);
    };

    TextBuffer.prototype.findInRange = function(regex, range) {
      return this.buffer.findInRange(regex, range);
    };

    TextBuffer.prototype.findSync = function(regex) {
      return this.buffer.findSync(regex);
    };

    TextBuffer.prototype.findInRangeSync = function(regex, range) {
      return this.buffer.findInRangeSync(regex, range);
    };

    TextBuffer.prototype.findAll = function(regex) {
      return this.buffer.findAll(regex);
    };

    TextBuffer.prototype.findAllInRange = function(regex, range) {
      return this.buffer.findAllInRange(regex, range);
    };

    TextBuffer.prototype.findAllSync = function(regex) {
      return this.buffer.findAllSync(regex);
    };

    TextBuffer.prototype.findAllInRangeSync = function(regex, range) {
      return this.buffer.findAllInRangeSync(regex, range);
    };

    TextBuffer.prototype.findWordsWithSubsequence = function(query, extraWordCharacters, maxCount) {
      return this.buffer.findWordsWithSubsequence(query, extraWordCharacters, maxCount);
    };

    TextBuffer.prototype.findWordsWithSubsequenceInRange = function(query, extraWordCharacters, maxCount, range) {
      return this.buffer.findWordsWithSubsequenceInRange(query, extraWordCharacters, maxCount, range);
    };


    /*
    Section: Buffer Range Details
     */

    TextBuffer.prototype.getRange = function() {
      return new Range(this.getFirstPosition(), this.getEndPosition());
    };

    TextBuffer.prototype.getLineCount = function() {
      return this.buffer.getLineCount();
    };

    TextBuffer.prototype.getLastRow = function() {
      return this.getLineCount() - 1;
    };

    TextBuffer.prototype.getFirstPosition = function() {
      return new Point(0, 0);
    };

    TextBuffer.prototype.getEndPosition = function() {
      return Point.fromObject(this.buffer.getExtent());
    };

    TextBuffer.prototype.getMaxCharacterIndex = function() {
      return this.characterIndexForPosition(Point.INFINITY);
    };

    TextBuffer.prototype.rangeForRow = function(row, includeNewline) {
      row = Math.max(row, 0);
      row = Math.min(row, this.getLastRow());
      if (includeNewline && row < this.getLastRow()) {
        return new Range(new Point(row, 0), new Point(row + 1, 0));
      } else {
        return new Range(new Point(row, 0), new Point(row, this.lineLengthForRow(row)));
      }
    };

    TextBuffer.prototype.characterIndexForPosition = function(position) {
      return this.buffer.characterIndexForPosition(Point.fromObject(position));
    };

    TextBuffer.prototype.positionForCharacterIndex = function(offset) {
      return Point.fromObject(this.buffer.positionForCharacterIndex(offset));
    };

    TextBuffer.prototype.clipRange = function(range) {
      var end, start;
      range = Range.fromObject(range);
      start = this.clipPosition(range.start);
      end = this.clipPosition(range.end);
      if (range.start.isEqual(start) && range.end.isEqual(end)) {
        return range;
      } else {
        return new Range(start, end);
      }
    };

    TextBuffer.prototype.clipPosition = function(position, options) {
      var column, lineLength, row;
      position = Point.fromObject(position);
      Point.assertValid(position);
      row = position.row, column = position.column;
      if (row < 0) {
        return this.getFirstPosition();
      } else if (row > this.getLastRow()) {
        return this.getEndPosition();
      } else if (column < 0) {
        return Point(row, 0);
      } else {
        lineLength = this.lineLengthForRow(row);
        if (column >= lineLength && (options != null ? options.clipDirection : void 0) === 'forward' && row < this.getLastRow()) {
          return Point(row + 1, 0);
        } else if (column > lineLength) {
          return Point(row, lineLength);
        } else {
          return position;
        }
      }
    };


    /*
    Section: Buffer Operations
     */

    TextBuffer.prototype.save = function() {
      return this.saveTo(this.file);
    };

    TextBuffer.prototype.saveAs = function(filePath) {
      if (!filePath) {
        throw new Error("Can't save buffer with no file path");
      }
      return this.saveTo(new File(filePath));
    };

    TextBuffer.prototype.saveTo = function(file) {
      var destination, directoryPromise, filePath;
      if (this.destroyed) {
        throw new Error("Can't save destroyed buffer");
      }
      if (!file) {
        throw new Error("Can't save a buffer with no file");
      }
      filePath = file.getPath();
      if (file instanceof File) {
        directoryPromise = new Promise(function(resolve, reject) {
          return mkdirp(path.dirname(filePath), function(error) {
            if (error) {
              return reject(error);
            } else {
              return resolve();
            }
          });
        });
        destination = filePath;
      } else {
        destination = file.createWriteStream();
        directoryPromise = Promise.resolve();
      }
      this.outstandingSaveCount++;
      return directoryPromise.then((function(_this) {
        return function() {
          return _this.emitter.emitAsync('will-save', {
            path: filePath
          });
        };
      })(this)).then((function(_this) {
        return function() {
          return _this.buffer.save(destination, _this.getEncoding());
        };
      })(this))["catch"]((function(_this) {
        return function(error) {
          var fsAdmin;
          if (process.platform === 'darwin' && error.code === 'EACCES' && destination === filePath) {
            fsAdmin = require('fs-admin');
            return _this.buffer.save(fsAdmin.createWriteStream(filePath), _this.getEncoding())["catch"](function() {
              throw error;
            });
          } else {
            throw error;
          }
        };
      })(this))["catch"]((function(_this) {
        return function(error) {
          _this.outstandingSaveCount--;
          throw error;
        };
      })(this)).then((function(_this) {
        return function() {
          _this.outstandingSaveCount--;
          _this.setFile(file);
          _this.fileHasChangedSinceLastLoad = false;
          _this.digestWhenLastPersisted = _this.buffer.baseTextDigest();
          _this.loaded = true;
          _this.emitModifiedStatusChanged(false);
          _this.emitter.emit('did-save', {
            path: filePath
          });
          return _this;
        };
      })(this));
    };

    TextBuffer.prototype.reload = function() {
      return this.load({
        discardChanges: true,
        internal: true
      });
    };


    /*
    Section: Display Layers
     */

    TextBuffer.prototype.addDisplayLayer = function(params) {
      var id;
      id = this.nextDisplayLayerId++;
      return this.displayLayers[id] = new DisplayLayer(id, this, params);
    };

    TextBuffer.prototype.getDisplayLayer = function(id) {
      return this.displayLayers[id];
    };

    TextBuffer.prototype.setDisplayLayers = function(displayLayers1) {
      this.displayLayers = displayLayers1;
    };

    TextBuffer.prototype.registerTextDecorationLayer = function(textDecorationLayer) {
      this.textDecorationLayers.add(textDecorationLayer);
      return new Disposable((function(_this) {
        return function() {
          return _this.textDecorationLayers["delete"](textDecorationLayer);
        };
      })(this));
    };


    /*
    Section: Private Utility Methods
     */

    TextBuffer.prototype.loadSync = function(options) {
      var checkpoint, error, error1, patch;
      if (!(options != null ? options.internal : void 0)) {
        Grim.deprecate('The .loadSync instance method is deprecated. Create a loaded buffer using TextBuffer.loadSync(filePath) instead.');
      }
      checkpoint = null;
      try {
        patch = this.buffer.loadSync(this.getPath(), this.getEncoding(), (function(_this) {
          return function(percentDone, patch) {
            if (patch && patch.getChangeCount() > 0) {
              checkpoint = _this.historyProvider.createCheckpoint({
                markers: _this.createMarkerSnapshot(),
                isBarrier: true
              });
              _this.emitter.emit('will-reload');
              return _this.emitWillChangeEvent();
            }
          };
        })(this));
      } catch (error1) {
        error = error1;
        if (!options.mustExist && error.code === 'ENOENT') {
          this.emitter.emit('did-reload');
          if (options != null ? options.discardChanges : void 0) {
            this.setText('');
          }
        } else {
          throw error;
        }
      }
      return this.finishLoading(checkpoint, patch);
    };

    TextBuffer.prototype.load = function(options) {
      var checkpoint, loadCount, source;
      if (!(options != null ? options.internal : void 0)) {
        Grim.deprecate('The .load instance method is deprecated. Create a loaded buffer using TextBuffer.load(filePath) instead.');
      }
      source = this.file instanceof File ? this.file.getPath() : this.file.createReadStream();
      checkpoint = null;
      loadCount = ++this.loadCount;
      return this.buffer.load(source, {
        encoding: this.getEncoding(),
        force: options != null ? options.discardChanges : void 0,
        patch: this.loaded
      }, (function(_this) {
        return function(percentDone, patch) {
          if (_this.loadCount > loadCount) {
            return false;
          }
          if (patch) {
            if (patch.getChangeCount() > 0) {
              checkpoint = _this.historyProvider.createCheckpoint({
                markers: _this.createMarkerSnapshot(),
                isBarrier: true
              });
              _this.emitter.emit('will-reload');
              return _this.emitWillChangeEvent();
            } else if (options != null ? options.discardChanges : void 0) {
              return _this.emitter.emit('will-reload');
            }
          }
        };
      })(this)).then((function(_this) {
        return function(patch) {
          return _this.finishLoading(checkpoint, patch, options);
        };
      })(this))["catch"]((function(_this) {
        return function(error) {
          if (!(options != null ? options.mustExist : void 0) && error.code === 'ENOENT') {
            _this.emitter.emit('will-reload');
            if (options != null ? options.discardChanges : void 0) {
              _this.setText('');
            }
            return _this.emitter.emit('did-reload');
          } else {
            throw error;
          }
        };
      })(this));
    };

    TextBuffer.prototype.finishLoading = function(checkpoint, patch, options) {
      var change, changes, id, j, len, markerLayer, markersSnapshot, ref4, ref5, ref6;
      if (this.isDestroyed() || (this.loaded && (checkpoint == null) && (patch != null))) {
        if (options != null ? options.discardChanges : void 0) {
          this.emitter.emit('did-reload');
        }
        return null;
      }
      this.fileHasChangedSinceLastLoad = false;
      this.digestWhenLastPersisted = this.buffer.baseTextDigest();
      this.cachedText = null;
      if (this.loaded && patch && patch.getChangeCount() > 0) {
        changes = patch.getChanges();
        if (options != null ? options.clearHistory : void 0) {
          this.historyProvider.clearUndoStack();
        } else {
          if (this.historyProvider.pushPatch) {
            this.historyProvider.pushPatch(patch);
          } else {
            this.historyProvider.pushChanges(changes);
          }
        }
        (ref4 = this.changesSinceLastDidChangeTextEvent).push.apply(ref4, changes);
        (ref5 = this.changesSinceLastStoppedChangingEvent).push.apply(ref5, changes);
        if (this.markerLayers != null) {
          for (j = 0, len = changes.length; j < len; j++) {
            change = changes[j];
            ref6 = this.markerLayers;
            for (id in ref6) {
              markerLayer = ref6[id];
              markerLayer.splice(change.newStart, traversal(change.oldEnd, change.oldStart), traversal(change.newEnd, change.newStart));
            }
          }
        }
        markersSnapshot = this.createMarkerSnapshot();
        this.historyProvider.groupChangesSinceCheckpoint(checkpoint, {
          markers: markersSnapshot,
          deleteCheckpoint: true
        });
        this.emitDidChangeEvent(new ChangeEvent(this, changes));
        this.emitDidChangeTextEvent();
        this.emitMarkerChangeEvents(markersSnapshot);
        this.emitModifiedStatusChanged(this.isModified());
      }
      this.loaded = true;
      this.emitter.emit('did-reload');
      return this;
    };

    TextBuffer.prototype.destroy = function() {
      var base, id, markerLayer, ref4, ref5, subscription;
      if (!this.destroyed) {
        this.destroyed = true;
        this.emitter.emit('did-destroy');
        this.emitter.clear();
        if ((ref4 = this.fileSubscriptions) != null) {
          ref4.dispose();
        }
        ref5 = this.markerLayers;
        for (id in ref5) {
          markerLayer = ref5[id];
          markerLayer.destroy();
        }
        if (this.outstandingSaveCount === 0) {
          this.buffer.reset('');
        } else {
          subscription = this.onDidSave((function(_this) {
            return function() {
              if (_this.outstandingSaveCount === 0) {
                _this.buffer.reset('');
                return subscription.dispose();
              }
            };
          })(this));
        }
        this.cachedText = null;
        return typeof (base = this.historyProvider).clear === "function" ? base.clear() : void 0;
      }
    };

    TextBuffer.prototype.isAlive = function() {
      return !this.destroyed;
    };

    TextBuffer.prototype.isDestroyed = function() {
      return this.destroyed;
    };

    TextBuffer.prototype.isRetained = function() {
      return this.refcount > 0;
    };

    TextBuffer.prototype.retain = function() {
      this.refcount++;
      return this;
    };

    TextBuffer.prototype.release = function() {
      this.refcount--;
      if (!this.isRetained()) {
        this.destroy();
      }
      return this;
    };

    TextBuffer.prototype.subscribeToFile = function() {
      var ref4;
      if ((ref4 = this.fileSubscriptions) != null) {
        ref4.dispose();
      }
      this.fileSubscriptions = new CompositeDisposable;
      if (this.file.onDidChange != null) {
        this.fileSubscriptions.add(this.file.onDidChange(debounce((function(_this) {
          return function() {
            var source;
            if (!_this.file.existsSync()) {
              return;
            }
            if (_this.outstandingSaveCount > 0) {
              return;
            }
            _this.fileHasChangedSinceLastLoad = true;
            if (_this.isModified()) {
              source = _this.file instanceof File ? _this.file.getPath() : _this.file.createReadStream();
              return _this.buffer.baseTextMatchesFile(source, _this.getEncoding()).then(function(matchesFile) {
                if (!matchesFile) {
                  return _this.emitter.emit('did-conflict');
                }
              });
            } else {
              return _this.load({
                internal: true
              });
            }
          };
        })(this), this.fileChangeDelay)));
      }
      if (this.file.onDidDelete != null) {
        this.fileSubscriptions.add(this.file.onDidDelete((function(_this) {
          return function() {
            var modified;
            modified = _this.buffer.isModified();
            _this.emitter.emit('did-delete');
            if (!modified && _this.shouldDestroyOnFileDelete()) {
              return _this.destroy();
            } else {
              return _this.emitModifiedStatusChanged(true);
            }
          };
        })(this)));
      }
      if (this.file.onDidRename != null) {
        this.fileSubscriptions.add(this.file.onDidRename((function(_this) {
          return function() {
            return _this.emitter.emit('did-change-path', _this.getPath());
          };
        })(this)));
      }
      if (this.file.onWillThrowWatchError != null) {
        return this.fileSubscriptions.add(this.file.onWillThrowWatchError((function(_this) {
          return function(error) {
            return _this.emitter.emit('will-throw-watch-error', error);
          };
        })(this)));
      }
    };

    TextBuffer.prototype.createMarkerSnapshot = function() {
      var markerLayer, markerLayerId, ref4, snapshot;
      snapshot = {};
      ref4 = this.markerLayers;
      for (markerLayerId in ref4) {
        markerLayer = ref4[markerLayerId];
        if (markerLayer.maintainHistory) {
          snapshot[markerLayerId] = markerLayer.createSnapshot();
        }
      }
      return snapshot;
    };

    TextBuffer.prototype.restoreFromMarkerSnapshot = function(snapshot) {
      var layerSnapshot, markerLayerId, ref4, results;
      results = [];
      for (markerLayerId in snapshot) {
        layerSnapshot = snapshot[markerLayerId];
        results.push((ref4 = this.markerLayers[markerLayerId]) != null ? ref4.restoreFromSnapshot(layerSnapshot) : void 0);
      }
      return results;
    };

    TextBuffer.prototype.emitMarkerChangeEvents = function(snapshot) {
      var j, len, markerLayer, markerLayerId, ref4, results, updatedMarkerLayers;
      if (this.transactCallDepth === 0) {
        while (this.markerLayersWithPendingUpdateEvents.size > 0) {
          updatedMarkerLayers = Array.from(this.markerLayersWithPendingUpdateEvents);
          this.markerLayersWithPendingUpdateEvents.clear();
          for (j = 0, len = updatedMarkerLayers.length; j < len; j++) {
            markerLayer = updatedMarkerLayers[j];
            markerLayer.emitUpdateEvent();
            if (markerLayer === this.defaultMarkerLayer) {
              this.emitter.emit('did-update-markers');
            }
          }
        }
      }
      ref4 = this.markerLayers;
      results = [];
      for (markerLayerId in ref4) {
        markerLayer = ref4[markerLayerId];
        results.push(markerLayer.emitChangeEvents(snapshot != null ? snapshot[markerLayerId] : void 0));
      }
      return results;
    };

    TextBuffer.prototype.emitWillChangeEvent = function() {
      if (!this._emittedWillChangeEvent) {
        this.emitter.emit('will-change');
        return this._emittedWillChangeEvent = true;
      }
    };

    TextBuffer.prototype.emitDidChangeTextEvent = function() {
      var compactedChanges, displayLayer, id, ref4;
      if (this.transactCallDepth === 0) {
        if (this.changesSinceLastDidChangeTextEvent.length > 0) {
          compactedChanges = patchFromChanges(this.changesSinceLastDidChangeTextEvent).getChanges();
          this.changesSinceLastDidChangeTextEvent.length = 0;
          if (compactedChanges.length > 0) {
            this.emitter.emit('did-change-text', new ChangeEvent(this, compactedChanges));
          }
          this.debouncedEmitDidStopChangingEvent();
          this._emittedWillChangeEvent = false;
        }
        ref4 = this.displayLayers;
        for (id in ref4) {
          displayLayer = ref4[id];
          displayLayer.emitDeferredChangeEvents();
        }
      }
    };

    TextBuffer.prototype.hasMultipleEditors = function() {
      return this.refcount > 1;
    };

    TextBuffer.prototype.emitDidStopChangingEvent = function() {
      var compactedChanges, modifiedStatus;
      if (this.destroyed) {
        return;
      }
      modifiedStatus = this.isModified();
      compactedChanges = Object.freeze(normalizePatchChanges(patchFromChanges(this.changesSinceLastStoppedChangingEvent).getChanges()));
      this.changesSinceLastStoppedChangingEvent.length = 0;
      this.emitter.emit('did-stop-changing', {
        changes: compactedChanges
      });
      return this.emitModifiedStatusChanged(modifiedStatus);
    };

    TextBuffer.prototype.emitModifiedStatusChanged = function(modifiedStatus) {
      if (modifiedStatus === this.previousModifiedStatus) {
        return;
      }
      this.previousModifiedStatus = modifiedStatus;
      return this.emitter.emit('did-change-modified', modifiedStatus);
    };

    TextBuffer.prototype.logLines = function(start, end) {
      var j, line, ref4, ref5, row;
      if (start == null) {
        start = 0;
      }
      if (end == null) {
        end = this.getLastRow();
      }
      for (row = j = ref4 = start, ref5 = end; ref4 <= ref5 ? j <= ref5 : j >= ref5; row = ref4 <= ref5 ? ++j : --j) {
        line = this.lineForRow(row);
        console.log(row, line, line.length);
      }
    };


    /*
    Section: Private History Delegate Methods
     */

    TextBuffer.prototype.invertChange = function(change) {
      return Object.freeze({
        oldRange: change.newRange,
        newRange: change.oldRange,
        oldText: change.newText,
        newText: change.oldText
      });
    };

    TextBuffer.prototype.serializeChange = function(change) {
      return {
        oldRange: change.oldRange.serialize(),
        newRange: change.newRange.serialize(),
        oldText: change.oldText,
        newText: change.newText
      };
    };

    TextBuffer.prototype.deserializeChange = function(change) {
      return {
        oldRange: Range.deserialize(change.oldRange),
        newRange: Range.deserialize(change.newRange),
        oldText: change.oldText,
        newText: change.newText
      };
    };

    TextBuffer.prototype.serializeSnapshot = function(snapshot, options) {
      if (!options.markerLayers) {
        return;
      }
      return MarkerLayer.serializeSnapshot(snapshot);
    };

    TextBuffer.prototype.deserializeSnapshot = function(snapshot) {
      return MarkerLayer.deserializeSnapshot(snapshot);
    };


    /*
    Section: Private MarkerLayer Delegate Methods
     */

    TextBuffer.prototype.markerLayerDestroyed = function(markerLayer) {
      return delete this.markerLayers[markerLayer.id];
    };

    TextBuffer.prototype.markerCreated = function(layer, marker) {
      if (layer === this.defaultMarkerLayer) {
        return this.emitter.emit('did-create-marker', marker);
      }
    };

    TextBuffer.prototype.markersUpdated = function(layer) {
      if (this.transactCallDepth === 0) {
        layer.emitUpdateEvent();
        if (layer === this.defaultMarkerLayer) {
          return this.emitter.emit('did-update-markers');
        }
      } else {
        return this.markerLayersWithPendingUpdateEvents.add(layer);
      }
    };

    TextBuffer.prototype.getNextMarkerId = function() {
      return this.nextMarkerId++;
    };

    return TextBuffer;

  })();

}).call(this);
