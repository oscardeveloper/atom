{
  "classes": {
    "DisplayMarkerLayer": {
      "name": "DisplayMarkerLayer",
      "filename": "src/display-marker-layer.coffee",
      "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/display-marker-layer.coffee#L11",
      "sections": [
        {
          "name": "Lifecycle",
          "description": ""
        },
        {
          "name": "Event Subscription",
          "description": ""
        },
        {
          "name": "Marker creation",
          "description": ""
        },
        {
          "name": "Querying",
          "description": ""
        }
      ],
      "classMethods": [],
      "instanceMethods": [
        {
          "name": "destroy",
          "sectionName": "Lifecycle",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/display-marker-layer.coffee#L27",
          "visibility": "Essential",
          "summary": "Destroy this layer. ",
          "description": "Destroy this layer. "
        },
        {
          "name": "clear",
          "sectionName": "Lifecycle",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/display-marker-layer.coffee#L39",
          "visibility": "Public",
          "summary": "Destroy all markers in this layer. ",
          "description": "Destroy all markers in this layer. "
        },
        {
          "name": "isDestroyed",
          "sectionName": "Lifecycle",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/display-marker-layer.coffee#L49",
          "visibility": "Essential",
          "summary": "Determine whether this layer has been destroyed.",
          "description": "Determine whether this layer has been destroyed.",
          "returnValues": [
            {
              "type": "Boolean",
              "description": "Returns a {Boolean}."
            }
          ]
        },
        {
          "name": "onDidDestroy",
          "sectionName": "Event Subscription",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/display-marker-layer.coffee#L59",
          "visibility": "Public",
          "summary": "Subscribe to be notified synchronously when this layer is destroyed.",
          "description": "Subscribe to be notified synchronously when this layer is destroyed.",
          "returnValues": [
            {
              "type": "Disposable",
              "description": "Returns a {Disposable}."
            }
          ]
        },
        {
          "name": "onDidUpdate",
          "sectionName": "Event Subscription",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/display-marker-layer.coffee#L77",
          "visibility": "Public",
          "summary": "Subscribe to be notified asynchronously whenever markers are\ncreated, updated, or destroyed on this layer. *Prefer this method for\noptimal performance when interacting with layers that could contain large\nnumbers of markers.*",
          "description": "Subscribe to be notified asynchronously whenever markers are\ncreated, updated, or destroyed on this layer. *Prefer this method for\noptimal performance when interacting with layers that could contain large\nnumbers of markers.*\n\nSubscribers are notified once, asynchronously when any number of changes\noccur in a given tick of the event loop. You should re-query the layer\nto determine the state of markers in which you're interested in. It may\nbe counter-intuitive, but this is much more efficient than subscribing to\nevents on individual markers, which are expensive to deliver.",
          "arguments": [
            {
              "name": "callback",
              "description": "A {Function} that will be called with no arguments when changes occur on this layer.",
              "type": "Function",
              "isOptional": false
            }
          ],
          "returnValues": [
            {
              "type": "Disposable",
              "description": "Returns a {Disposable}."
            }
          ]
        },
        {
          "name": "onDidCreateMarker",
          "sectionName": "Event Subscription",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/display-marker-layer.coffee#L91",
          "visibility": "Public",
          "summary": "Subscribe to be notified synchronously whenever markers are created\non this layer. *Avoid this method for optimal performance when interacting\nwith layers that could contain large numbers of markers.*",
          "description": "Subscribe to be notified synchronously whenever markers are created\non this layer. *Avoid this method for optimal performance when interacting\nwith layers that could contain large numbers of markers.*\n\nYou should prefer {onDidUpdate} when synchronous notifications aren't\nabsolutely necessary.",
          "arguments": [
            {
              "name": "callback",
              "description": "A {Function} that will be called with a {TextEditorMarker} whenever a new marker is created.",
              "type": "Function",
              "isOptional": false
            }
          ],
          "returnValues": [
            {
              "type": "Disposable",
              "description": "Returns a {Disposable}."
            }
          ]
        },
        {
          "name": "markScreenRange",
          "sectionName": "Marker creation",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/display-marker-layer.coffee#L133",
          "visibility": "Public",
          "summary": "Create a marker with the given screen range.",
          "description": "Create a marker with the given screen range.",
          "arguments": [
            {
              "name": "range",
              "description": "A {Range} or range-compatible {Array}",
              "type": "Range",
              "isOptional": false
            },
            {
              "children": [
                {
                  "name": "reversed",
                  "description": "{Boolean} Creates the marker in a reversed orientation. (default: false)",
                  "type": "Boolean",
                  "isOptional": true
                },
                {
                  "name": "invalidate",
                  "description": "{String} Determines the rules by which changes to the buffer *invalidate* the marker. (default: 'overlap') It can be any of the following strategies, in order of fragility:\n* __never__: The marker is never marked as invalid. This is a good choice for\n  markers representing selections in an editor.\n* __surround__: The marker is invalidated by changes that completely surround it.\n* __overlap__: The marker is invalidated by changes that surround the\n  start or end of the marker. This is the default.\n* __inside__: The marker is invalidated by changes that extend into the\n  inside of the marker. Changes that end at the marker's start or\n  start at the marker's end do not invalidate the marker.\n* __touch__: The marker is invalidated by a change that touches the marked\n  region in any way, including changes that end at the marker's\n  start or start at the marker's end. This is the most fragile strategy.",
                  "type": "String",
                  "isOptional": true
                },
                {
                  "name": "exclusive",
                  "description": "{Boolean} indicating whether insertions at the start or end of the marked range should be interpreted as happening *outside* the marker. Defaults to `false`, except when using the `inside` invalidation strategy or when when the marker has no tail, in which case it defaults to true. Explicitly assigning this option overrides behavior in all circumstances.",
                  "type": "Boolean",
                  "isOptional": false
                },
                {
                  "name": "clipDirection",
                  "description": "{String} If `'backward'`, returns the first valid position preceding an invalid position. If `'forward'`, returns the first valid position following an invalid position. If `'closest'`, returns the first valid position closest to an invalid position. Defaults to `'closest'`. Applies to the start and end of the given range.",
                  "type": "String",
                  "isOptional": false
                }
              ],
              "name": "options",
              "description": "A hash of key-value pairs to associate with the marker. There are also reserved property names that have marker-specific meaning.",
              "type": null,
              "isOptional": false
            }
          ],
          "returnValues": [
            {
              "type": "DisplayMarker",
              "description": "Returns a {DisplayMarker}."
            }
          ]
        },
        {
          "name": "markScreenPosition",
          "sectionName": "Marker creation",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/display-marker-layer.coffee#L170",
          "visibility": "Public",
          "summary": "Create a marker on this layer with its head at the given screen\nposition and no tail.",
          "description": "Create a marker on this layer with its head at the given screen\nposition and no tail.",
          "arguments": [
            {
              "name": "screenPosition",
              "description": "A {Point} or point-compatible {Array}",
              "type": "Point",
              "isOptional": false
            },
            {
              "children": [
                {
                  "name": "invalidate",
                  "description": "{String} Determines the rules by which changes to the buffer *invalidate* the marker. (default: 'overlap') It can be any of the following strategies, in order of fragility:\n* __never__: The marker is never marked as invalid. This is a good choice for\n  markers representing selections in an editor.\n* __surround__: The marker is invalidated by changes that completely surround it.\n* __overlap__: The marker is invalidated by changes that surround the\n  start or end of the marker. This is the default.\n* __inside__: The marker is invalidated by changes that extend into the\n  inside of the marker. Changes that end at the marker's start or\n  start at the marker's end do not invalidate the marker.\n* __touch__: The marker is invalidated by a change that touches the marked\n  region in any way, including changes that end at the marker's\n  start or start at the marker's end. This is the most fragile strategy.",
                  "type": "String",
                  "isOptional": true
                },
                {
                  "name": "exclusive",
                  "description": "{Boolean} indicating whether insertions at the start or end of the marked range should be interpreted as happening *outside* the marker. Defaults to `false`, except when using the `inside` invalidation strategy or when when the marker has no tail, in which case it defaults to true. Explicitly assigning this option overrides behavior in all circumstances.",
                  "type": "Boolean",
                  "isOptional": false
                },
                {
                  "name": "clipDirection",
                  "description": "{String} If `'backward'`, returns the first valid position preceding an invalid position. If `'forward'`, returns the first valid position following an invalid position. If `'closest'`, returns the first valid position closest to an invalid position. Defaults to `'closest'`.",
                  "type": "String",
                  "isOptional": false
                }
              ],
              "name": "options",
              "description": "An {Object} with the following keys:",
              "type": "Object",
              "isOptional": true
            }
          ],
          "returnValues": [
            {
              "type": "DisplayMarker",
              "description": "Returns a {DisplayMarker}."
            }
          ]
        },
        {
          "name": "markBufferRange",
          "sectionName": "Marker creation",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/display-marker-layer.coffee#L204",
          "visibility": "Public",
          "summary": "Create a marker with the given buffer range.",
          "description": "Create a marker with the given buffer range.",
          "arguments": [
            {
              "name": "range",
              "description": "A {Range} or range-compatible {Array}",
              "type": "Range",
              "isOptional": false
            },
            {
              "children": [
                {
                  "name": "reversed",
                  "description": "{Boolean} Creates the marker in a reversed orientation. (default: false)",
                  "type": "Boolean",
                  "isOptional": true
                },
                {
                  "name": "invalidate",
                  "description": "{String} Determines the rules by which changes to the buffer *invalidate* the marker. (default: 'overlap') It can be any of the following strategies, in order of fragility:\n* __never__: The marker is never marked as invalid. This is a good choice for\n  markers representing selections in an editor.\n* __surround__: The marker is invalidated by changes that completely surround it.\n* __overlap__: The marker is invalidated by changes that surround the\n  start or end of the marker. This is the default.\n* __inside__: The marker is invalidated by changes that extend into the\n  inside of the marker. Changes that end at the marker's start or\n  start at the marker's end do not invalidate the marker.\n* __touch__: The marker is invalidated by a change that touches the marked\n  region in any way, including changes that end at the marker's\n  start or start at the marker's end. This is the most fragile strategy.",
                  "type": "String",
                  "isOptional": true
                },
                {
                  "name": "exclusive",
                  "description": "{Boolean} indicating whether insertions at the start or end of the marked range should be interpreted as happening *outside* the marker. Defaults to `false`, except when using the `inside` invalidation strategy or when when the marker has no tail, in which case it defaults to true. Explicitly assigning this option overrides behavior in all circumstances.",
                  "type": "Boolean",
                  "isOptional": false
                }
              ],
              "name": "options",
              "description": "A hash of key-value pairs to associate with the marker. There are also reserved property names that have marker-specific meaning.",
              "type": null,
              "isOptional": false
            }
          ],
          "returnValues": [
            {
              "type": "DisplayMarker",
              "description": "Returns a {DisplayMarker}."
            }
          ]
        },
        {
          "name": "markBufferPosition",
          "sectionName": "Marker creation",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/display-marker-layer.coffee#L235",
          "visibility": "Public",
          "summary": "Create a marker on this layer with its head at the given buffer\nposition and no tail.",
          "description": "Create a marker on this layer with its head at the given buffer\nposition and no tail.",
          "arguments": [
            {
              "name": "bufferPosition",
              "description": "A {Point} or point-compatible {Array}",
              "type": "Point",
              "isOptional": false
            },
            {
              "children": [
                {
                  "name": "invalidate",
                  "description": "{String} Determines the rules by which changes to the buffer *invalidate* the marker. (default: 'overlap') It can be any of the following strategies, in order of fragility:\n* __never__: The marker is never marked as invalid. This is a good choice for\n  markers representing selections in an editor.\n* __surround__: The marker is invalidated by changes that completely surround it.\n* __overlap__: The marker is invalidated by changes that surround the\n  start or end of the marker. This is the default.\n* __inside__: The marker is invalidated by changes that extend into the\n  inside of the marker. Changes that end at the marker's start or\n  start at the marker's end do not invalidate the marker.\n* __touch__: The marker is invalidated by a change that touches the marked\n  region in any way, including changes that end at the marker's\n  start or start at the marker's end. This is the most fragile strategy.",
                  "type": "String",
                  "isOptional": true
                },
                {
                  "name": "exclusive",
                  "description": "{Boolean} indicating whether insertions at the start or end of the marked range should be interpreted as happening *outside* the marker. Defaults to `false`, except when using the `inside` invalidation strategy or when when the marker has no tail, in which case it defaults to true. Explicitly assigning this option overrides behavior in all circumstances.",
                  "type": "Boolean",
                  "isOptional": false
                }
              ],
              "name": "options",
              "description": "An {Object} with the following keys:",
              "type": "Object",
              "isOptional": true
            }
          ],
          "returnValues": [
            {
              "type": "DisplayMarker",
              "description": "Returns a {DisplayMarker}."
            }
          ]
        },
        {
          "name": "getMarker",
          "sectionName": "Querying",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/display-marker-layer.coffee#L245",
          "visibility": "Essential",
          "summary": "Get an existing marker by its id.",
          "description": "Get an existing marker by its id.",
          "returnValues": [
            {
              "type": "DisplayMarker",
              "description": "Returns a {DisplayMarker}."
            }
          ]
        },
        {
          "name": "getMarkers",
          "sectionName": "Querying",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/display-marker-layer.coffee#L254",
          "visibility": "Essential",
          "summary": "Get all markers in the layer.",
          "description": "Get all markers in the layer.",
          "returnValues": [
            {
              "type": "Array",
              "description": "Returns an {Array} of {DisplayMarker}s."
            }
          ]
        },
        {
          "name": "getMarkerCount",
          "sectionName": "Querying",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/display-marker-layer.coffee#L260",
          "visibility": "Public",
          "summary": "Get the number of markers in the marker layer.",
          "description": "Get the number of markers in the marker layer.",
          "returnValues": [
            {
              "type": "Number",
              "description": "Returns a {Number}."
            }
          ]
        },
        {
          "name": "findMarkers",
          "sectionName": "Querying",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/display-marker-layer.coffee#L298",
          "visibility": "Public",
          "summary": "Find markers in the layer conforming to the given parameters.",
          "description": "Find markers in the layer conforming to the given parameters.\n\nThis method finds markers based on the given properties. Markers can be\nassociated with custom properties that will be compared with basic equality.\nIn addition, there are several special properties that will be compared\nwith the range of the markers rather than their properties.",
          "arguments": [
            {
              "children": [
                {
                  "name": "startBufferPosition",
                  "description": "Only include markers starting at this {Point} in buffer coordinates.",
                  "type": "Point",
                  "isOptional": false
                },
                {
                  "name": "endBufferPosition",
                  "description": "Only include markers ending at this {Point} in buffer coordinates.",
                  "type": "Point",
                  "isOptional": false
                },
                {
                  "name": "startScreenPosition",
                  "description": "Only include markers starting at this {Point} in screen coordinates.",
                  "type": "Point",
                  "isOptional": false
                },
                {
                  "name": "endScreenPosition",
                  "description": "Only include markers ending at this {Point} in screen coordinates.",
                  "type": "Point",
                  "isOptional": false
                },
                {
                  "name": "startsInBufferRange",
                  "description": "Only include markers starting inside this {Range} in buffer coordinates.",
                  "type": "Range",
                  "isOptional": false
                },
                {
                  "name": "endsInBufferRange",
                  "description": "Only include markers ending inside this {Range} in buffer coordinates.",
                  "type": "Range",
                  "isOptional": false
                },
                {
                  "name": "startsInScreenRange",
                  "description": "Only include markers starting inside this {Range} in screen coordinates.",
                  "type": "Range",
                  "isOptional": false
                },
                {
                  "name": "endsInScreenRange",
                  "description": "Only include markers ending inside this {Range} in screen coordinates.",
                  "type": "Range",
                  "isOptional": false
                },
                {
                  "name": "startBufferRow",
                  "description": "Only include markers starting at this row in buffer coordinates.",
                  "type": null,
                  "isOptional": false
                },
                {
                  "name": "endBufferRow",
                  "description": "Only include markers ending at this row in buffer coordinates.",
                  "type": null,
                  "isOptional": false
                },
                {
                  "name": "startScreenRow",
                  "description": "Only include markers starting at this row in screen coordinates.",
                  "type": null,
                  "isOptional": false
                },
                {
                  "name": "endScreenRow",
                  "description": "Only include markers ending at this row in screen coordinates.",
                  "type": null,
                  "isOptional": false
                },
                {
                  "name": "intersectsBufferRowRange",
                  "description": "Only include markers intersecting this {Array}  of `[startRow, endRow]` in buffer coordinates.",
                  "type": "Array",
                  "isOptional": false
                },
                {
                  "name": "intersectsScreenRowRange",
                  "description": "Only include markers intersecting this {Array}  of `[startRow, endRow]` in screen coordinates.",
                  "type": "Array",
                  "isOptional": false
                },
                {
                  "name": "containsBufferRange",
                  "description": "Only include markers containing this {Range} in buffer coordinates.",
                  "type": "Range",
                  "isOptional": false
                },
                {
                  "name": "containsBufferPosition",
                  "description": "Only include markers containing this {Point} in buffer coordinates.",
                  "type": "Point",
                  "isOptional": false
                },
                {
                  "name": "containedInBufferRange",
                  "description": "Only include markers contained in this {Range} in buffer coordinates.",
                  "type": "Range",
                  "isOptional": false
                },
                {
                  "name": "containedInScreenRange",
                  "description": "Only include markers contained in this {Range} in screen coordinates.",
                  "type": "Range",
                  "isOptional": false
                },
                {
                  "name": "intersectsBufferRange",
                  "description": "Only include markers intersecting this {Range} in buffer coordinates.",
                  "type": "Range",
                  "isOptional": false
                },
                {
                  "name": "intersectsScreenRange",
                  "description": "Only include markers intersecting this {Range} in screen coordinates.",
                  "type": "Range",
                  "isOptional": false
                }
              ],
              "name": "properties",
              "description": "An {Object} containing properties that each returned marker must satisfy. Markers can be associated with custom properties, which are compared with basic equality. In addition, several reserved properties can be used to filter markers based on their current range:",
              "type": "Object",
              "isOptional": false
            }
          ],
          "returnValues": [
            {
              "type": "Array",
              "description": "Returns an {Array} of {DisplayMarker}s"
            }
          ]
        }
      ],
      "classProperties": [],
      "instanceProperties": [],
      "visibility": "Public",
      "summary": "*Experimental:* A container for a related set of markers at the\n{DisplayLayer} level. Wraps an underlying {MarkerLayer} on the {TextBuffer}.",
      "description": "*Experimental:* A container for a related set of markers at the\n{DisplayLayer} level. Wraps an underlying {MarkerLayer} on the {TextBuffer}.\n\nThis API is experimental and subject to change on any release. "
    },
    "DisplayMarker": {
      "name": "DisplayMarker",
      "filename": "src/display-marker.coffee",
      "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/display-marker.coffee#L43",
      "sections": [
        {
          "name": "Construction and Destruction",
          "description": ""
        },
        {
          "name": "Event Subscription",
          "description": ""
        },
        {
          "name": "TextEditorMarker Details",
          "description": ""
        },
        {
          "name": "Comparing to other markers",
          "description": ""
        },
        {
          "name": "Managing the marker's range",
          "description": ""
        }
      ],
      "classMethods": [],
      "instanceMethods": [
        {
          "name": "destroy",
          "sectionName": "Construction and Destruction",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/display-marker.coffee#L56",
          "visibility": "Essential",
          "summary": "Destroys the marker, causing it to emit the 'destroyed' event. Once\ndestroyed, a marker cannot be restored by undo/redo operations. ",
          "description": "Destroys the marker, causing it to emit the 'destroyed' event. Once\ndestroyed, a marker cannot be restored by undo/redo operations. "
        },
        {
          "name": "copy",
          "sectionName": "Construction and Destruction",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/display-marker.coffee#L81",
          "visibility": "Essential",
          "summary": "Creates and returns a new {DisplayMarker} with the same properties as\nthis marker.",
          "description": "Creates and returns a new {DisplayMarker} with the same properties as\nthis marker.\n\n{Selection} markers (markers with a custom property `type: \"selection\"`)\nshould be copied with a different `type` value, for example with\n`marker.copy({type: null})`. Otherwise, the new marker's selection will\nbe merged with this marker's selection, and a `null` value will be\nreturned.",
          "arguments": [
            {
              "name": "properties",
              "description": "{Object} properties to associate with the new marker. The new marker's properties are computed by extending this marker's properties with `properties`.",
              "type": "Object",
              "isOptional": true
            }
          ],
          "returnValues": [
            {
              "type": "DisplayMarker",
              "description": "Returns a {DisplayMarker}."
            }
          ]
        },
        {
          "name": "onDidChange",
          "sectionName": "Event Subscription",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/display-marker.coffee#L110",
          "visibility": "Essential",
          "summary": "Invoke the given callback when the state of the marker changes.",
          "description": "Invoke the given callback when the state of the marker changes.",
          "arguments": [
            {
              "children": [
                {
                  "children": [
                    {
                      "name": "oldHeadBufferPosition",
                      "description": "{Point} representing the former head buffer position",
                      "type": "Point",
                      "isOptional": false
                    },
                    {
                      "name": "newHeadBufferPosition",
                      "description": "{Point} representing the new head buffer position",
                      "type": "Point",
                      "isOptional": false
                    },
                    {
                      "name": "oldTailBufferPosition",
                      "description": "{Point} representing the former tail buffer position",
                      "type": "Point",
                      "isOptional": false
                    },
                    {
                      "name": "newTailBufferPosition",
                      "description": "{Point} representing the new tail buffer position",
                      "type": "Point",
                      "isOptional": false
                    },
                    {
                      "name": "oldHeadScreenPosition",
                      "description": "{Point} representing the former head screen position",
                      "type": "Point",
                      "isOptional": false
                    },
                    {
                      "name": "newHeadScreenPosition",
                      "description": "{Point} representing the new head screen position",
                      "type": "Point",
                      "isOptional": false
                    },
                    {
                      "name": "oldTailScreenPosition",
                      "description": "{Point} representing the former tail screen position",
                      "type": "Point",
                      "isOptional": false
                    },
                    {
                      "name": "newTailScreenPosition",
                      "description": "{Point} representing the new tail screen position",
                      "type": "Point",
                      "isOptional": false
                    },
                    {
                      "name": "wasValid",
                      "description": "{Boolean} indicating whether the marker was valid before the change",
                      "type": "Boolean",
                      "isOptional": false
                    },
                    {
                      "name": "isValid",
                      "description": "{Boolean} indicating whether the marker is now valid",
                      "type": "Boolean",
                      "isOptional": false
                    },
                    {
                      "name": "hadTail",
                      "description": "{Boolean} indicating whether the marker had a tail before the change",
                      "type": "Boolean",
                      "isOptional": false
                    },
                    {
                      "name": "hasTail",
                      "description": "{Boolean} indicating whether the marker now has a tail",
                      "type": "Boolean",
                      "isOptional": false
                    },
                    {
                      "name": "oldProperties",
                      "description": "{Object} containing the marker's custom properties before the change.",
                      "type": "Object",
                      "isOptional": false
                    },
                    {
                      "name": "newProperties",
                      "description": "{Object} containing the marker's custom properties after the change.",
                      "type": "Object",
                      "isOptional": false
                    },
                    {
                      "name": "textChanged",
                      "description": "{Boolean} indicating whether this change was caused by a textual change to the buffer or whether the marker was manipulated directly via its public API.",
                      "type": "Boolean",
                      "isOptional": false
                    }
                  ],
                  "name": "event",
                  "description": "{Object} with the following keys:",
                  "type": "Object",
                  "isOptional": false
                }
              ],
              "name": "callback",
              "description": "{Function} to be called when the marker changes.",
              "type": "Function",
              "isOptional": false
            }
          ],
          "returnValues": [
            {
              "type": "Disposable",
              "description": "Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."
            }
          ]
        },
        {
          "name": "onDidDestroy",
          "sectionName": "Event Subscription",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/display-marker.coffee#L126",
          "visibility": "Essential",
          "summary": "Invoke the given callback when the marker is destroyed.",
          "description": "Invoke the given callback when the marker is destroyed.",
          "arguments": [
            {
              "name": "callback",
              "description": "{Function} to be called when the marker is destroyed.",
              "type": "Function",
              "isOptional": false
            }
          ],
          "returnValues": [
            {
              "type": "Disposable",
              "description": "Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."
            }
          ]
        },
        {
          "name": "isValid",
          "sectionName": "TextEditorMarker Details",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/display-marker.coffee#L137",
          "visibility": "Essential",
          "summary": "",
          "description": "",
          "returnValues": [
            {
              "type": "Boolean",
              "description": "Returns a {Boolean} indicating whether the marker is valid.\nMarkers can be invalidated when a region surrounding them in the buffer is\nchanged."
            }
          ]
        },
        {
          "name": "isDestroyed",
          "sectionName": "TextEditorMarker Details",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/display-marker.coffee#L145",
          "visibility": "Essential",
          "summary": "",
          "description": "",
          "returnValues": [
            {
              "type": "Boolean",
              "description": "Returns a {Boolean} indicating whether the marker has been\ndestroyed. A marker can be invalid without being destroyed, in which case\nundoing the invalidating operation would restore the marker. Once a marker\nis destroyed by calling {DisplayMarker::destroy}, no undo/redo operation\ncan ever bring it back."
            }
          ]
        },
        {
          "name": "isReversed",
          "sectionName": "TextEditorMarker Details",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/display-marker.coffee#L149",
          "visibility": "Essential",
          "summary": "",
          "description": "",
          "returnValues": [
            {
              "type": "Boolean",
              "description": "Returns a {Boolean} indicating whether the head precedes the tail."
            }
          ]
        },
        {
          "name": "isExclusive",
          "sectionName": "TextEditorMarker Details",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/display-marker.coffee#L154",
          "visibility": "Essential",
          "summary": "",
          "description": "",
          "returnValues": [
            {
              "type": "Boolean",
              "description": "Returns a {Boolean} indicating whether changes that occur exactly\nat the marker's head or tail cause it to move."
            }
          ]
        },
        {
          "name": "getInvalidationStrategy",
          "sectionName": "TextEditorMarker Details",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/display-marker.coffee#L162",
          "visibility": "Essential",
          "summary": "Get the invalidation strategy for this marker.",
          "description": "Get the invalidation strategy for this marker.\n\nValid values include: `never`, `surround`, `overlap`, `inside`, and `touch`.",
          "returnValues": [
            {
              "type": "String",
              "description": "Returns a {String}."
            }
          ]
        },
        {
          "name": "getProperties",
          "sectionName": "TextEditorMarker Details",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/display-marker.coffee#L167",
          "visibility": "Essential",
          "summary": "",
          "description": "",
          "returnValues": [
            {
              "type": "Object",
              "description": "Returns an {Object} containing any custom properties associated with\nthe marker."
            }
          ]
        },
        {
          "name": "setProperties",
          "sectionName": "TextEditorMarker Details",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/display-marker.coffee#L174",
          "visibility": "Essential",
          "summary": "Merges an {Object} containing new properties into the marker's\nexisting properties.",
          "description": "Merges an {Object} containing new properties into the marker's\nexisting properties.",
          "arguments": [
            {
              "name": "properties",
              "description": "{Object} ",
              "type": "Object",
              "isOptional": false
            }
          ]
        },
        {
          "name": "matchesProperties",
          "sectionName": "TextEditorMarker Details",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/display-marker.coffee#L179",
          "visibility": "Essential",
          "summary": "",
          "description": "",
          "returnValues": [
            {
              "type": null,
              "description": "Returns whether this marker matches the given parameters. The\nparameters are the same as {DisplayMarkerLayer::findMarkers}."
            }
          ]
        },
        {
          "name": "compare",
          "sectionName": "Comparing to other markers",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/display-marker.coffee#L192",
          "visibility": "Essential",
          "summary": "Compares this marker to another based on their ranges.",
          "description": "Compares this marker to another based on their ranges.",
          "arguments": [
            {
              "name": "other",
              "description": "{DisplayMarker}",
              "type": "DisplayMarker",
              "isOptional": false
            }
          ],
          "returnValues": [
            {
              "type": "Number",
              "description": "Returns a {Number}"
            }
          ]
        },
        {
          "name": "isEqual",
          "sectionName": "Comparing to other markers",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/display-marker.coffee#L199",
          "visibility": "Essential",
          "summary": "",
          "description": "",
          "arguments": [
            {
              "name": "other",
              "description": "{DisplayMarker} other marker ",
              "type": "DisplayMarker",
              "isOptional": false
            }
          ],
          "returnValues": [
            {
              "type": "Boolean",
              "description": "Returns a {Boolean} indicating whether this marker is equivalent to\nanother marker, meaning they have the same range and options."
            }
          ]
        },
        {
          "name": "getBufferRange",
          "sectionName": "Managing the marker's range",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/display-marker.coffee#L210",
          "visibility": "Essential",
          "summary": "Gets the buffer range of this marker.",
          "description": "Gets the buffer range of this marker.",
          "returnValues": [
            {
              "type": "Range",
              "description": "Returns a {Range}."
            }
          ]
        },
        {
          "name": "getScreenRange",
          "sectionName": "Managing the marker's range",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/display-marker.coffee#L216",
          "visibility": "Essential",
          "summary": "Gets the screen range of this marker.",
          "description": "Gets the screen range of this marker.",
          "returnValues": [
            {
              "type": "Range",
              "description": "Returns a {Range}."
            }
          ]
        },
        {
          "name": "setBufferRange",
          "sectionName": "Managing the marker's range",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/display-marker.coffee#L224",
          "visibility": "Essential",
          "summary": "Modifies the buffer range of this marker.",
          "description": "Modifies the buffer range of this marker.",
          "arguments": [
            {
              "name": "bufferRange",
              "description": "The new {Range} to use",
              "type": "Range",
              "isOptional": false
            },
            {
              "children": [
                {
                  "name": "reversed",
                  "description": "{Boolean} If true, the marker will to be in a reversed orientation. ",
                  "type": "Boolean",
                  "isOptional": false
                }
              ],
              "name": "properties",
              "description": "{Object} properties to associate with the marker.",
              "type": "Object",
              "isOptional": true
            }
          ]
        },
        {
          "name": "setScreenRange",
          "sectionName": "Managing the marker's range",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/display-marker.coffee#L237",
          "visibility": "Essential",
          "summary": "Modifies the screen range of this marker.",
          "description": "Modifies the screen range of this marker.",
          "arguments": [
            {
              "name": "screenRange",
              "description": "The new {Range} to use",
              "type": "Range",
              "isOptional": false
            },
            {
              "children": [
                {
                  "name": "reversed",
                  "description": "{Boolean} If true, the marker will to be in a reversed orientation.",
                  "type": "Boolean",
                  "isOptional": false
                },
                {
                  "name": "clipDirection",
                  "description": "{String} If `'backward'`, returns the first valid position preceding an invalid position. If `'forward'`, returns the first valid position following an invalid position. If `'closest'`, returns the first valid position closest to an invalid position. Defaults to `'closest'`. Applies to the start and end of the given range. ",
                  "type": "String",
                  "isOptional": false
                }
              ],
              "name": "options",
              "description": "An {Object} with the following keys:",
              "type": "Object",
              "isOptional": true
            }
          ]
        },
        {
          "name": "getHeadBufferPosition",
          "sectionName": "Managing the marker's range",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/display-marker.coffee#L243",
          "visibility": "Extended",
          "summary": "Retrieves the buffer position of the marker's head.",
          "description": "Retrieves the buffer position of the marker's head.",
          "returnValues": [
            {
              "type": "Point",
              "description": "Returns a {Point}."
            }
          ]
        },
        {
          "name": "setHeadBufferPosition",
          "sectionName": "Managing the marker's range",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/display-marker.coffee#L249",
          "visibility": "Extended",
          "summary": "Sets the buffer position of the marker's head.",
          "description": "Sets the buffer position of the marker's head.",
          "arguments": [
            {
              "name": "bufferPosition",
              "description": "The new {Point} to use ",
              "type": "Point",
              "isOptional": false
            }
          ]
        },
        {
          "name": "getHeadScreenPosition",
          "sectionName": "Managing the marker's range",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/display-marker.coffee#L262",
          "visibility": "Extended",
          "summary": "Retrieves the screen position of the marker's head.",
          "description": "Retrieves the screen position of the marker's head.",
          "arguments": [
            {
              "children": [
                {
                  "name": "clipDirection",
                  "description": "{String} If `'backward'`, returns the first valid position preceding an invalid position. If `'forward'`, returns the first valid position following an invalid position. If `'closest'`, returns the first valid position closest to an invalid position. Defaults to `'closest'`. Applies to the start and end of the given range.",
                  "type": "String",
                  "isOptional": false
                }
              ],
              "name": "options",
              "description": "An {Object} with the following keys:",
              "type": "Object",
              "isOptional": true
            }
          ],
          "returnValues": [
            {
              "type": "Point",
              "description": "Returns a {Point}."
            }
          ]
        },
        {
          "name": "setHeadScreenPosition",
          "sectionName": "Managing the marker's range",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/display-marker.coffee#L274",
          "visibility": "Extended",
          "summary": "Sets the screen position of the marker's head.",
          "description": "Sets the screen position of the marker's head.",
          "arguments": [
            {
              "name": "screenPosition",
              "description": "The new {Point} to use",
              "type": "Point",
              "isOptional": false
            },
            {
              "children": [
                {
                  "name": "clipDirection",
                  "description": "{String} If `'backward'`, returns the first valid position preceding an invalid position. If `'forward'`, returns the first valid position following an invalid position. If `'closest'`, returns the first valid position closest to an invalid position. Defaults to `'closest'`. Applies to the start and end of the given range. ",
                  "type": "String",
                  "isOptional": false
                }
              ],
              "name": "options",
              "description": "An {Object} with the following keys:",
              "type": "Object",
              "isOptional": true
            }
          ]
        },
        {
          "name": "getTailBufferPosition",
          "sectionName": "Managing the marker's range",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/display-marker.coffee#L280",
          "visibility": "Extended",
          "summary": "Retrieves the buffer position of the marker's tail.",
          "description": "Retrieves the buffer position of the marker's tail.",
          "returnValues": [
            {
              "type": "Point",
              "description": "Returns a {Point}."
            }
          ]
        },
        {
          "name": "setTailBufferPosition",
          "sectionName": "Managing the marker's range",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/display-marker.coffee#L286",
          "visibility": "Extended",
          "summary": "Sets the buffer position of the marker's tail.",
          "description": "Sets the buffer position of the marker's tail.",
          "arguments": [
            {
              "name": "bufferPosition",
              "description": "The new {Point} to use ",
              "type": "Point",
              "isOptional": false
            }
          ]
        },
        {
          "name": "getTailScreenPosition",
          "sectionName": "Managing the marker's range",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/display-marker.coffee#L299",
          "visibility": "Extended",
          "summary": "Retrieves the screen position of the marker's tail.",
          "description": "Retrieves the screen position of the marker's tail.",
          "arguments": [
            {
              "children": [
                {
                  "name": "clipDirection",
                  "description": "{String} If `'backward'`, returns the first valid position preceding an invalid position. If `'forward'`, returns the first valid position following an invalid position. If `'closest'`, returns the first valid position closest to an invalid position. Defaults to `'closest'`. Applies to the start and end of the given range.",
                  "type": "String",
                  "isOptional": false
                }
              ],
              "name": "options",
              "description": "An {Object} with the following keys:",
              "type": "Object",
              "isOptional": true
            }
          ],
          "returnValues": [
            {
              "type": "Point",
              "description": "Returns a {Point}."
            }
          ]
        },
        {
          "name": "setTailScreenPosition",
          "sectionName": "Managing the marker's range",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/display-marker.coffee#L311",
          "visibility": "Extended",
          "summary": "Sets the screen position of the marker's tail.",
          "description": "Sets the screen position of the marker's tail.",
          "arguments": [
            {
              "name": "screenPosition",
              "description": "The new {Point} to use",
              "type": "Point",
              "isOptional": false
            },
            {
              "children": [
                {
                  "name": "clipDirection",
                  "description": "{String} If `'backward'`, returns the first valid position preceding an invalid position. If `'forward'`, returns the first valid position following an invalid position. If `'closest'`, returns the first valid position closest to an invalid position. Defaults to `'closest'`. Applies to the start and end of the given range. ",
                  "type": "String",
                  "isOptional": false
                }
              ],
              "name": "options",
              "description": "An {Object} with the following keys:",
              "type": "Object",
              "isOptional": true
            }
          ]
        },
        {
          "name": "getStartBufferPosition",
          "sectionName": "Managing the marker's range",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/display-marker.coffee#L318",
          "visibility": "Extended",
          "summary": "Retrieves the buffer position of the marker's start. This will always be\nless than or equal to the result of {DisplayMarker::getEndBufferPosition}.",
          "description": "Retrieves the buffer position of the marker's start. This will always be\nless than or equal to the result of {DisplayMarker::getEndBufferPosition}.",
          "returnValues": [
            {
              "type": "Point",
              "description": "Returns a {Point}."
            }
          ]
        },
        {
          "name": "getStartScreenPosition",
          "sectionName": "Managing the marker's range",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/display-marker.coffee#L332",
          "visibility": "Essential",
          "summary": "Retrieves the screen position of the marker's start. This will always be\nless than or equal to the result of {DisplayMarker::getEndScreenPosition}.",
          "description": "Retrieves the screen position of the marker's start. This will always be\nless than or equal to the result of {DisplayMarker::getEndScreenPosition}.",
          "arguments": [
            {
              "children": [
                {
                  "name": "clipDirection",
                  "description": "{String} If `'backward'`, returns the first valid position preceding an invalid position. If `'forward'`, returns the first valid position following an invalid position. If `'closest'`, returns the first valid position closest to an invalid position. Defaults to `'closest'`. Applies to the start and end of the given range.",
                  "type": "String",
                  "isOptional": false
                }
              ],
              "name": "options",
              "description": "An {Object} with the following keys:",
              "type": "Object",
              "isOptional": true
            }
          ],
          "returnValues": [
            {
              "type": "Point",
              "description": "Returns a {Point}."
            }
          ]
        },
        {
          "name": "getEndBufferPosition",
          "sectionName": "Managing the marker's range",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/display-marker.coffee#L339",
          "visibility": "Extended",
          "summary": "Retrieves the buffer position of the marker's end. This will always be\ngreater than or equal to the result of {DisplayMarker::getStartBufferPosition}.",
          "description": "Retrieves the buffer position of the marker's end. This will always be\ngreater than or equal to the result of {DisplayMarker::getStartBufferPosition}.",
          "returnValues": [
            {
              "type": "Point",
              "description": "Returns a {Point}."
            }
          ]
        },
        {
          "name": "getEndScreenPosition",
          "sectionName": "Managing the marker's range",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/display-marker.coffee#L353",
          "visibility": "Essential",
          "summary": "Retrieves the screen position of the marker's end. This will always be\ngreater than or equal to the result of {DisplayMarker::getStartScreenPosition}.",
          "description": "Retrieves the screen position of the marker's end. This will always be\ngreater than or equal to the result of {DisplayMarker::getStartScreenPosition}.",
          "arguments": [
            {
              "children": [
                {
                  "name": "clipDirection",
                  "description": "{String} If `'backward'`, returns the first valid position preceding an invalid position. If `'forward'`, returns the first valid position following an invalid position. If `'closest'`, returns the first valid position closest to an invalid position. Defaults to `'closest'`. Applies to the start and end of the given range.",
                  "type": "String",
                  "isOptional": false
                }
              ],
              "name": "options",
              "description": "An {Object} with the following keys:",
              "type": "Object",
              "isOptional": true
            }
          ],
          "returnValues": [
            {
              "type": "Point",
              "description": "Returns a {Point}."
            }
          ]
        },
        {
          "name": "hasTail",
          "sectionName": "Managing the marker's range",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/display-marker.coffee#L357",
          "visibility": "Extended",
          "summary": "",
          "description": "",
          "returnValues": [
            {
              "type": "Boolean",
              "description": "Returns a {Boolean} indicating whether the marker has a tail."
            }
          ]
        },
        {
          "name": "plantTail",
          "sectionName": "Managing the marker's range",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/display-marker.coffee#L363",
          "visibility": "Extended",
          "summary": "Plants the marker's tail at the current head position. After calling\nthe marker's tail position will be its head position at the time of the\ncall, regardless of where the marker's head is moved. ",
          "description": "Plants the marker's tail at the current head position. After calling\nthe marker's tail position will be its head position at the time of the\ncall, regardless of where the marker's head is moved. "
        },
        {
          "name": "clearTail",
          "sectionName": "Managing the marker's range",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/display-marker.coffee#L369",
          "visibility": "Extended",
          "summary": "Removes the marker's tail. After calling the marker's head position\nwill be reported as its current tail position until the tail is planted\nagain. ",
          "description": "Removes the marker's tail. After calling the marker's head position\nwill be reported as its current tail position until the tail is planted\nagain. "
        }
      ],
      "classProperties": [],
      "instanceProperties": [],
      "visibility": "Essential",
      "summary": "Represents a buffer annotation that remains logically stationary\neven as the buffer changes. This is used to represent cursors, folds, snippet\ntargets, misspelled words, and anything else that needs to track a logical\nlocation in the buffer over time.",
      "description": "Represents a buffer annotation that remains logically stationary\neven as the buffer changes. This is used to represent cursors, folds, snippet\ntargets, misspelled words, and anything else that needs to track a logical\nlocation in the buffer over time.\n\n### DisplayMarker Creation\n\nUse {DisplayMarkerLayer::markBufferRange} or {DisplayMarkerLayer::markScreenRange}\nrather than creating Markers directly.\n\n### Head and Tail\n\nMarkers always have a *head* and sometimes have a *tail*. If you think of a\nmarker as an editor selection, the tail is the part that's stationary and the\nhead is the part that moves when the mouse is moved. A marker without a tail\nalways reports an empty range at the head position. A marker with a head position\ngreater than the tail is in a \"normal\" orientation. If the head precedes the\ntail the marker is in a \"reversed\" orientation.\n\n### Validity\n\nMarkers are considered *valid* when they are first created. Depending on the\ninvalidation strategy you choose, certain changes to the buffer can cause a\nmarker to become invalid, for example if the text surrounding the marker is\ndeleted. The strategies, in order of descending fragility:\n\n* __never__: The marker is never marked as invalid. This is a good choice for\n  markers representing selections in an editor.\n* __surround__: The marker is invalidated by changes that completely surround it.\n* __overlap__: The marker is invalidated by changes that surround the\n  start or end of the marker. This is the default.\n* __inside__: The marker is invalidated by changes that extend into the\n  inside of the marker. Changes that end at the marker's start or\n  start at the marker's end do not invalidate the marker.\n* __touch__: The marker is invalidated by a change that touches the marked\n  region in any way, including changes that end at the marker's\n  start or start at the marker's end. This is the most fragile strategy.\n\nSee {TextBuffer::markRange} for usage. "
    },
    "MarkerLayer": {
      "name": "MarkerLayer",
      "filename": "src/marker-layer.coffee",
      "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/marker-layer.coffee#L15",
      "sections": [
        {
          "name": "Lifecycle",
          "description": ""
        },
        {
          "name": "Querying",
          "description": ""
        },
        {
          "name": "Marker creation",
          "description": ""
        },
        {
          "name": "Event subscription",
          "description": ""
        }
      ],
      "classMethods": [],
      "instanceMethods": [
        {
          "name": "copy",
          "sectionName": "Lifecycle",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/marker-layer.coffee#L49",
          "visibility": "Public",
          "summary": "Create a copy of this layer with markers in the same state and\nlocations. ",
          "description": "Create a copy of this layer with markers in the same state and\nlocations. "
        },
        {
          "name": "destroy",
          "sectionName": "Lifecycle",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/marker-layer.coffee#L57",
          "visibility": "Public",
          "summary": "Destroy this layer. ",
          "description": "Destroy this layer. "
        },
        {
          "name": "clear",
          "sectionName": "Lifecycle",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/marker-layer.coffee#L68",
          "visibility": "Public",
          "summary": "Remove all markers from this layer. ",
          "description": "Remove all markers from this layer. "
        },
        {
          "name": "isDestroyed",
          "sectionName": "Lifecycle",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/marker-layer.coffee#L77",
          "visibility": "Public",
          "summary": "Determine whether this layer has been destroyed. ",
          "description": "Determine whether this layer has been destroyed. "
        },
        {
          "name": "getMarker",
          "sectionName": "Querying",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/marker-layer.coffee#L90",
          "visibility": "Public",
          "summary": "Get an existing marker by its id.",
          "description": "Get an existing marker by its id.",
          "returnValues": [
            {
              "type": "Marker",
              "description": "Returns a {Marker}."
            }
          ]
        },
        {
          "name": "getMarkers",
          "sectionName": "Querying",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/marker-layer.coffee#L96",
          "visibility": "Public",
          "summary": "Get all existing markers on the marker layer.",
          "description": "Get all existing markers on the marker layer.",
          "returnValues": [
            {
              "type": "Array",
              "description": "Returns an {Array} of {Marker}s."
            }
          ]
        },
        {
          "name": "getMarkerCount",
          "sectionName": "Querying",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/marker-layer.coffee#L102",
          "visibility": "Public",
          "summary": "Get the number of markers in the marker layer.",
          "description": "Get the number of markers in the marker layer.",
          "returnValues": [
            {
              "type": "Number",
              "description": "Returns a {Number}."
            }
          ]
        },
        {
          "name": "findMarkers",
          "sectionName": "Querying",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/marker-layer.coffee#L108",
          "visibility": "Public",
          "summary": "Find markers in the layer conforming to the given parameters.",
          "description": "Find markers in the layer conforming to the given parameters.\n\nSee the documentation for {TextBuffer::findMarkers}. "
        },
        {
          "name": "markRange",
          "sectionName": "Marker creation",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/marker-layer.coffee#L190",
          "visibility": "Public",
          "summary": "Create a marker with the given range.",
          "description": "Create a marker with the given range.",
          "arguments": [
            {
              "name": "range",
              "description": "A {Range} or range-compatible {Array}",
              "type": "Range",
              "isOptional": false
            },
            {
              "children": [
                {
                  "name": "reversed",
                  "description": "{Boolean} Creates the marker in a reversed orientation. (default: false)",
                  "type": "Boolean",
                  "isOptional": true
                },
                {
                  "name": "invalidate",
                  "description": "{String} Determines the rules by which changes to the buffer *invalidate* the marker. (default: 'overlap') It can be any of the following strategies, in order of fragility:\n* __never__: The marker is never marked as invalid. This is a good choice for\n  markers representing selections in an editor.\n* __surround__: The marker is invalidated by changes that completely surround it.\n* __overlap__: The marker is invalidated by changes that surround the\n  start or end of the marker. This is the default.\n* __inside__: The marker is invalidated by changes that extend into the\n  inside of the marker. Changes that end at the marker's start or\n  start at the marker's end do not invalidate the marker.\n* __touch__: The marker is invalidated by a change that touches the marked\n  region in any way, including changes that end at the marker's\n  start or start at the marker's end. This is the most fragile strategy.",
                  "type": "String",
                  "isOptional": true
                },
                {
                  "name": "exclusive",
                  "description": "{Boolean} indicating whether insertions at the start or end of the marked range should be interpreted as happening *outside* the marker. Defaults to `false`, except when using the `inside` invalidation strategy or when when the marker has no tail, in which case it defaults to true. Explicitly assigning this option overrides behavior in all circumstances.",
                  "type": "Boolean",
                  "isOptional": false
                }
              ],
              "name": "options",
              "description": "A hash of key-value pairs to associate with the marker. There are also reserved property names that have marker-specific meaning.",
              "type": null,
              "isOptional": false
            }
          ],
          "returnValues": [
            {
              "type": "Marker",
              "description": "Returns a {Marker}."
            }
          ]
        },
        {
          "name": "markPosition",
          "sectionName": "Marker creation",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/marker-layer.coffee#L219",
          "visibility": "Public",
          "summary": "Create a marker at with its head at the given position with no tail.",
          "description": "Create a marker at with its head at the given position with no tail.",
          "arguments": [
            {
              "name": "position",
              "description": "{Point} or point-compatible {Array}",
              "type": "Point",
              "isOptional": false
            },
            {
              "children": [
                {
                  "name": "invalidate",
                  "description": "{String} Determines the rules by which changes to the buffer *invalidate* the marker. (default: 'overlap') It can be any of the following strategies, in order of fragility:\n* __never__: The marker is never marked as invalid. This is a good choice for\n  markers representing selections in an editor.\n* __surround__: The marker is invalidated by changes that completely surround it.\n* __overlap__: The marker is invalidated by changes that surround the\n  start or end of the marker. This is the default.\n* __inside__: The marker is invalidated by changes that extend into the\n  inside of the marker. Changes that end at the marker's start or\n  start at the marker's end do not invalidate the marker.\n* __touch__: The marker is invalidated by a change that touches the marked\n  region in any way, including changes that end at the marker's\n  start or start at the marker's end. This is the most fragile strategy.",
                  "type": "String",
                  "isOptional": true
                },
                {
                  "name": "exclusive",
                  "description": "{Boolean} indicating whether insertions at the start or end of the marked range should be interpreted as happening *outside* the marker. Defaults to `false`, except when using the `inside` invalidation strategy or when when the marker has no tail, in which case it defaults to true. Explicitly assigning this option overrides behavior in all circumstances.",
                  "type": "Boolean",
                  "isOptional": false
                }
              ],
              "name": "options",
              "description": "An {Object} with the following keys:",
              "type": "Object",
              "isOptional": true
            }
          ],
          "returnValues": [
            {
              "type": "Marker",
              "description": "Returns a {Marker}."
            }
          ]
        },
        {
          "name": "onDidUpdate",
          "sectionName": "Event subscription",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/marker-layer.coffee#L244",
          "visibility": "Public",
          "summary": "Subscribe to be notified asynchronously whenever markers are\ncreated, updated, or destroyed on this layer. *Prefer this method for\noptimal performance when interacting with layers that could contain large\nnumbers of markers.*",
          "description": "Subscribe to be notified asynchronously whenever markers are\ncreated, updated, or destroyed on this layer. *Prefer this method for\noptimal performance when interacting with layers that could contain large\nnumbers of markers.*\n\nSubscribers are notified once, asynchronously when any number of changes\noccur in a given tick of the event loop. You should re-query the layer\nto determine the state of markers in which you're interested in. It may\nbe counter-intuitive, but this is much more efficient than subscribing to\nevents on individual markers, which are expensive to deliver.",
          "arguments": [
            {
              "name": "callback",
              "description": "A {Function} that will be called with no arguments when changes occur on this layer.",
              "type": "Function",
              "isOptional": false
            }
          ],
          "returnValues": [
            {
              "type": "Disposable",
              "description": "Returns a {Disposable}."
            }
          ]
        },
        {
          "name": "onDidCreateMarker",
          "sectionName": "Event subscription",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/marker-layer.coffee#L258",
          "visibility": "Public",
          "summary": "Subscribe to be notified synchronously whenever markers are created\non this layer. *Avoid this method for optimal performance when interacting\nwith layers that could contain large numbers of markers.*",
          "description": "Subscribe to be notified synchronously whenever markers are created\non this layer. *Avoid this method for optimal performance when interacting\nwith layers that could contain large numbers of markers.*\n\nYou should prefer {onDidUpdate} when synchronous notifications aren't\nabsolutely necessary.",
          "arguments": [
            {
              "name": "callback",
              "description": "A {Function} that will be called with a {Marker} whenever a new marker is created.",
              "type": "Function",
              "isOptional": false
            }
          ],
          "returnValues": [
            {
              "type": "Disposable",
              "description": "Returns a {Disposable}."
            }
          ]
        },
        {
          "name": "onDidDestroy",
          "sectionName": "Event subscription",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/marker-layer.coffee#L265",
          "visibility": "Public",
          "summary": "Subscribe to be notified synchronously when this layer is destroyed.",
          "description": "Subscribe to be notified synchronously when this layer is destroyed.",
          "returnValues": [
            {
              "type": "Disposable",
              "description": "Returns a {Disposable}."
            }
          ]
        }
      ],
      "classProperties": [],
      "instanceProperties": [],
      "visibility": "Public",
      "summary": "*Experimental:* A container for a related set of markers.",
      "description": "*Experimental:* A container for a related set of markers.\n\nThis API is experimental and subject to change on any release. "
    },
    "Point": {
      "name": "Point",
      "filename": "src/point.coffee",
      "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/point.coffee#L12",
      "sections": [
        {
          "name": "Properties",
          "description": ""
        },
        {
          "name": "Construction",
          "description": ""
        },
        {
          "name": "Comparison",
          "description": ""
        },
        {
          "name": "Construction",
          "description": ""
        },
        {
          "name": "Operations",
          "description": ""
        },
        {
          "name": "Comparison",
          "description": ""
        },
        {
          "name": "Conversion",
          "description": ""
        }
      ],
      "classMethods": [
        {
          "name": "fromObject",
          "sectionName": "Construction",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/point.coffee#L36",
          "visibility": "Public",
          "summary": "Convert any point-compatible object to a {Point}.",
          "description": "Convert any point-compatible object to a {Point}.",
          "arguments": [
            {
              "name": "object",
              "description": "This can be an object that's already a {Point}, in which case it's simply returned, or an array containing two {Number}s representing the row and column.",
              "type": "Point",
              "isOptional": false
            },
            {
              "name": "copy",
              "description": "An optional boolean indicating whether to force the copying of objects that are already points.",
              "type": null,
              "isOptional": false
            }
          ],
          "returnValues": [
            {
              "type": "Point",
              "description": "Returns: A {Point} based on the given object."
            }
          ]
        },
        {
          "name": "min",
          "sectionName": "Comparison",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/point.coffee#L55",
          "visibility": "Public",
          "summary": "",
          "description": "",
          "arguments": [
            {
              "name": "point1",
              "description": "{Point}",
              "type": "Point",
              "isOptional": false
            },
            {
              "name": "point2",
              "description": "{Point} ",
              "type": "Point",
              "isOptional": false
            }
          ],
          "returnValues": [
            {
              "type": "Point",
              "description": "Returns the given {Point} that is earlier in the buffer."
            }
          ]
        }
      ],
      "instanceMethods": [
        {
          "name": "constructor",
          "sectionName": "Construction",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/point.coffee#L87",
          "visibility": "Public",
          "summary": "Construct a {Point} object",
          "description": "Construct a {Point} object",
          "arguments": [
            {
              "name": "row",
              "description": "{Number} row",
              "type": "Number",
              "isOptional": false
            },
            {
              "name": "column",
              "description": "{Number} column ",
              "type": "Number",
              "isOptional": false
            }
          ]
        },
        {
          "name": "copy",
          "sectionName": "Construction",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/point.coffee#L94",
          "visibility": "Public",
          "summary": "",
          "description": "",
          "returnValues": [
            {
              "type": "Point",
              "description": "Returns a new {Point} with the same row and column."
            }
          ]
        },
        {
          "name": "negate",
          "sectionName": "Construction",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/point.coffee#L98",
          "visibility": "Public",
          "summary": "",
          "description": "",
          "returnValues": [
            {
              "type": "Point",
              "description": "Returns a new {Point} with the row and column negated."
            }
          ]
        },
        {
          "name": "freeze",
          "sectionName": "Operations",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/point.coffee#L108",
          "visibility": "Public",
          "summary": "Makes this point immutable and returns itself.",
          "description": "Makes this point immutable and returns itself.",
          "returnValues": [
            {
              "type": "Point",
              "description": "Returns an immutable version of this {Point}"
            }
          ]
        },
        {
          "name": "translate",
          "sectionName": "Operations",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/point.coffee#L118",
          "visibility": "Public",
          "summary": "Build and return a new point by adding the rows and columns of\nthe given point.",
          "description": "Build and return a new point by adding the rows and columns of\nthe given point.",
          "arguments": [
            {
              "name": "other",
              "description": "A {Point} whose row and column will be added to this point's row and column to build the returned point.",
              "type": "Point",
              "isOptional": false
            }
          ],
          "returnValues": [
            {
              "type": "Point",
              "description": "Returns a {Point}."
            }
          ]
        },
        {
          "name": "traverse",
          "sectionName": "Operations",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/point.coffee#L142",
          "visibility": "Public",
          "summary": "Build and return a new {Point} by traversing the rows and columns\nspecified by the given point.",
          "description": "Build and return a new {Point} by traversing the rows and columns\nspecified by the given point.\n\nThis method differs from the direct, vector-style addition offered by\n{::translate}. Rather than adding the rows and columns directly, it derives\nthe new point from traversing in \"typewriter space\". At the end of every row\ntraversed, a carriage return occurs that returns the columns to 0 before\ncontinuing the traversal.",
          "arguments": [
            {
              "name": "other",
              "description": "A {Point} providing the rows and columns to traverse by.",
              "type": "Point",
              "isOptional": false
            }
          ],
          "returnValues": [
            {
              "type": "Point",
              "description": "Returns a {Point}."
            }
          ]
        },
        {
          "name": "compare",
          "sectionName": "Comparison",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/point.coffee#L181",
          "visibility": "Public",
          "summary": "",
          "description": "",
          "arguments": [
            {
              "name": "other",
              "description": "A {Point} or point-compatible {Array}.",
              "type": "Point",
              "isOptional": false
            }
          ],
          "returnValues": [
            {
              "type": null,
              "description": "Returns `-1` if this point precedes the argument."
            },
            {
              "type": null,
              "description": "Returns `0` if this point is equivalent to the argument."
            },
            {
              "type": null,
              "description": "Returns `1` if this point follows the argument."
            }
          ]
        },
        {
          "name": "isEqual",
          "sectionName": "Comparison",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/point.coffee#L199",
          "visibility": "Public",
          "summary": "",
          "description": "",
          "arguments": [
            {
              "name": "other",
              "description": "A {Point} or point-compatible {Array}. ",
              "type": "Point",
              "isOptional": false
            }
          ],
          "returnValues": [
            {
              "type": "Boolean",
              "description": "Returns a {Boolean} indicating whether this point has the same row\nand column as the given {Point} or point-compatible {Array}."
            }
          ]
        },
        {
          "name": "isLessThan",
          "sectionName": "Comparison",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/point.coffee#L208",
          "visibility": "Public",
          "summary": "",
          "description": "",
          "arguments": [
            {
              "name": "other",
              "description": "A {Point} or point-compatible {Array}. ",
              "type": "Point",
              "isOptional": false
            }
          ],
          "returnValues": [
            {
              "type": "Boolean",
              "description": "Returns a {Boolean} indicating whether this point precedes the given\n{Point} or point-compatible {Array}."
            }
          ]
        },
        {
          "name": "isLessThanOrEqual",
          "sectionName": "Comparison",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/point.coffee#L215",
          "visibility": "Public",
          "summary": "",
          "description": "",
          "arguments": [
            {
              "name": "other",
              "description": "A {Point} or point-compatible {Array}. ",
              "type": "Point",
              "isOptional": false
            }
          ],
          "returnValues": [
            {
              "type": "Boolean",
              "description": "Returns a {Boolean} indicating whether this point precedes or is\nequal to the given {Point} or point-compatible {Array}."
            }
          ]
        },
        {
          "name": "isGreaterThan",
          "sectionName": "Comparison",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/point.coffee#L222",
          "visibility": "Public",
          "summary": "",
          "description": "",
          "arguments": [
            {
              "name": "other",
              "description": "A {Point} or point-compatible {Array}. ",
              "type": "Point",
              "isOptional": false
            }
          ],
          "returnValues": [
            {
              "type": "Boolean",
              "description": "Returns a {Boolean} indicating whether this point follows the given\n{Point} or point-compatible {Array}."
            }
          ]
        },
        {
          "name": "isGreaterThanOrEqual",
          "sectionName": "Comparison",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/point.coffee#L229",
          "visibility": "Public",
          "summary": "",
          "description": "",
          "arguments": [
            {
              "name": "other",
              "description": "A {Point} or point-compatible {Array}. ",
              "type": "Point",
              "isOptional": false
            }
          ],
          "returnValues": [
            {
              "type": "Boolean",
              "description": "Returns a {Boolean} indicating whether this point follows or is\nequal to the given {Point} or point-compatible {Array}."
            }
          ]
        },
        {
          "name": "toArray",
          "sectionName": "Conversion",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/point.coffee#L256",
          "visibility": "Public",
          "summary": "",
          "description": "",
          "returnValues": [
            {
              "type": null,
              "description": "Returns an array of this point's row and column."
            }
          ]
        },
        {
          "name": "serialize",
          "sectionName": "Conversion",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/point.coffee#L260",
          "visibility": "Public",
          "summary": "",
          "description": "",
          "returnValues": [
            {
              "type": null,
              "description": "Returns an array of this point's row and column."
            }
          ]
        },
        {
          "name": "toString",
          "sectionName": "Conversion",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/point.coffee#L264",
          "visibility": "Public",
          "summary": "",
          "description": "",
          "returnValues": [
            {
              "type": null,
              "description": "Returns a string representation of the point."
            }
          ]
        }
      ],
      "classProperties": [],
      "instanceProperties": [
        {
          "name": "row",
          "sectionName": "Properties",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/point.coffee#L18",
          "visibility": "Public",
          "summary": "A zero-indexed {Number} representing the row of the {Point}. ",
          "description": "A zero-indexed {Number} representing the row of the {Point}. "
        },
        {
          "name": "column",
          "sectionName": "Properties",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/point.coffee#L21",
          "visibility": "Public",
          "summary": "A zero-indexed {Number} representing the column of the {Point}. ",
          "description": "A zero-indexed {Number} representing the column of the {Point}. "
        }
      ],
      "visibility": "Public",
      "summary": "Represents a point in a buffer in row/column coordinates.",
      "description": "Represents a point in a buffer in row/column coordinates.\n\nEvery public method that takes a point also accepts a *point-compatible*\n{Array}. This means a 2-element array containing {Number}s representing the\nrow and column. So the following are equivalent:\n\n```coffee\nnew Point(1, 2)\n[1, 2] # Point compatible Array\n```"
    },
    "Range": {
      "name": "Range",
      "filename": "src/range.coffee",
      "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/range.coffee#L18",
      "sections": [
        {
          "name": "Properties",
          "description": ""
        },
        {
          "name": "Construction",
          "description": ""
        },
        {
          "name": "Serialization and Deserialization",
          "description": ""
        },
        {
          "name": "Construction",
          "description": ""
        },
        {
          "name": "Serialization and Deserialization",
          "description": ""
        },
        {
          "name": "Range Details",
          "description": ""
        },
        {
          "name": "Operations",
          "description": ""
        },
        {
          "name": "Comparison",
          "description": ""
        },
        {
          "name": "Conversion",
          "description": ""
        }
      ],
      "classMethods": [
        {
          "name": "fromObject",
          "sectionName": "Construction",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/range.coffee#L42",
          "visibility": "Public",
          "summary": "Convert any range-compatible object to a {Range}.",
          "description": "Convert any range-compatible object to a {Range}.",
          "arguments": [
            {
              "name": "object",
              "description": "This can be an object that's already a {Range}, in which case it's simply returned, or an array containing two {Point}s or point-compatible arrays.",
              "type": "Range",
              "isOptional": false
            },
            {
              "name": "copy",
              "description": "An optional boolean indicating whether to force the copying of objects that are already ranges.",
              "type": null,
              "isOptional": false
            }
          ],
          "returnValues": [
            {
              "type": "Range",
              "description": "Returns: A {Range} based on the given object."
            }
          ]
        },
        {
          "name": "deserialize",
          "sectionName": "Serialization and Deserialization",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/range.coffee#L102",
          "visibility": "Public",
          "summary": "Call this with the result of {Range::serialize} to construct a new Range.",
          "description": "Call this with the result of {Range::serialize} to construct a new Range.",
          "arguments": [
            {
              "name": "array",
              "description": "{Array} of params to pass to the {::constructor} ",
              "type": "Array",
              "isOptional": false
            }
          ]
        }
      ],
      "instanceMethods": [
        {
          "name": "constructor",
          "sectionName": "Construction",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/range.coffee#L116",
          "visibility": "Public",
          "summary": "Construct a {Range} object",
          "description": "Construct a {Range} object",
          "arguments": [
            {
              "name": "pointA",
              "description": "{Point} or Point compatible {Array} (default: [0,0])",
              "type": "Point",
              "isOptional": false
            },
            {
              "name": "pointB",
              "description": "{Point} or Point compatible {Array} (default: [0,0]) ",
              "type": "Point",
              "isOptional": false
            }
          ]
        },
        {
          "name": "copy",
          "sectionName": "Construction",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/range.coffee#L131",
          "visibility": "Public",
          "summary": "",
          "description": "",
          "returnValues": [
            {
              "type": null,
              "description": "Returns a new range with the same start and end positions."
            }
          ]
        },
        {
          "name": "negate",
          "sectionName": "Construction",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/range.coffee#L135",
          "visibility": "Public",
          "summary": "",
          "description": "",
          "returnValues": [
            {
              "type": null,
              "description": "Returns a new range with the start and end positions negated."
            }
          ]
        },
        {
          "name": "serialize",
          "sectionName": "Serialization and Deserialization",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/range.coffee#L143",
          "visibility": "Public",
          "summary": "",
          "description": "",
          "returnValues": [
            {
              "type": null,
              "description": "Returns a plain javascript object representation of the range."
            }
          ]
        },
        {
          "name": "isEmpty",
          "sectionName": "Range Details",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/range.coffee#L153",
          "visibility": "Public",
          "summary": "Is the start position of this range equal to the end position?",
          "description": "Is the start position of this range equal to the end position?",
          "returnValues": [
            {
              "type": "Boolean",
              "description": "Returns a {Boolean}."
            }
          ]
        },
        {
          "name": "isSingleLine",
          "sectionName": "Range Details",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/range.coffee#L158",
          "visibility": "Public",
          "summary": "",
          "description": "",
          "returnValues": [
            {
              "type": "Boolean",
              "description": "Returns a {Boolean} indicating whether this range starts and ends on\nthe same row."
            }
          ]
        },
        {
          "name": "getRowCount",
          "sectionName": "Range Details",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/range.coffee#L164",
          "visibility": "Public",
          "summary": "Get the number of rows in this range.",
          "description": "Get the number of rows in this range.",
          "returnValues": [
            {
              "type": "Number",
              "description": "Returns a {Number}."
            }
          ]
        },
        {
          "name": "getRows",
          "sectionName": "Range Details",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/range.coffee#L168",
          "visibility": "Public",
          "summary": "",
          "description": "",
          "returnValues": [
            {
              "type": null,
              "description": "Returns an array of all rows in the range."
            }
          ]
        },
        {
          "name": "freeze",
          "sectionName": "Operations",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/range.coffee#L179",
          "visibility": "Public",
          "summary": "Freezes the range and its start and end point so it becomes\nimmutable and returns itself.",
          "description": "Freezes the range and its start and end point so it becomes\nimmutable and returns itself.",
          "returnValues": [
            {
              "type": "Range",
              "description": "Returns an immutable version of this {Range}"
            }
          ]
        },
        {
          "name": "union",
          "sectionName": "Operations",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/range.coffee#L187",
          "visibility": "Public",
          "summary": "",
          "description": "",
          "arguments": [
            {
              "name": "otherRange",
              "description": "A {Range} or range-compatible {Array} ",
              "type": "Range",
              "isOptional": false
            }
          ],
          "returnValues": [
            {
              "type": null,
              "description": "Returns a new range that contains this range and the given range."
            }
          ]
        },
        {
          "name": "translate",
          "sectionName": "Operations",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/range.coffee#L200",
          "visibility": "Public",
          "summary": "Build and return a new range by translating this range's start and\nend points by the given delta(s).",
          "description": "Build and return a new range by translating this range's start and\nend points by the given delta(s).",
          "arguments": [
            {
              "name": "startDelta",
              "description": "A {Point} by which to translate the start of this range.",
              "type": "Point",
              "isOptional": false
            },
            {
              "name": "endDelta",
              "description": "A {Point} to by which to translate the end of this range. If omitted, the `startDelta` will be used instead.",
              "type": "Point",
              "isOptional": true
            }
          ],
          "returnValues": [
            {
              "type": "Range",
              "description": "Returns a {Range}."
            }
          ]
        },
        {
          "name": "traverse",
          "sectionName": "Operations",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/range.coffee#L212",
          "visibility": "Public",
          "summary": "Build and return a new range by traversing this range's start and\nend points by the given delta.",
          "description": "Build and return a new range by traversing this range's start and\nend points by the given delta.\n\nSee {Point::traverse} for details of how traversal differs from translation.",
          "arguments": [
            {
              "name": "delta",
              "description": "A {Point} containing the rows and columns to traverse to derive the new range.",
              "type": "Point",
              "isOptional": false
            }
          ],
          "returnValues": [
            {
              "type": "Range",
              "description": "Returns a {Range}."
            }
          ]
        },
        {
          "name": "compare",
          "sectionName": "Comparison",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/range.coffee#L226",
          "visibility": "Public",
          "summary": "Compare two Ranges",
          "description": "Compare two Ranges",
          "arguments": [
            {
              "name": "otherRange",
              "description": "A {Range} or range-compatible {Array}.",
              "type": "Range",
              "isOptional": false
            }
          ],
          "returnValues": [
            {
              "type": null,
              "description": "Returns `-1` if this range starts before the argument or contains it."
            },
            {
              "type": null,
              "description": "Returns `0` if this range is equivalent to the argument."
            },
            {
              "type": null,
              "description": "Returns `1` if this range starts after the argument or is contained by it."
            }
          ]
        },
        {
          "name": "isEqual",
          "sectionName": "Comparison",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/range.coffee#L237",
          "visibility": "Public",
          "summary": "",
          "description": "",
          "arguments": [
            {
              "name": "otherRange",
              "description": "A {Range} or range-compatible {Array}. ",
              "type": "Range",
              "isOptional": false
            }
          ],
          "returnValues": [
            {
              "type": "Boolean",
              "description": "Returns a {Boolean} indicating whether this range has the same start\nand end points as the given {Range} or range-compatible {Array}."
            }
          ]
        },
        {
          "name": "coversSameRows",
          "sectionName": "Comparison",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/range.coffee#L246",
          "visibility": "Public",
          "summary": "",
          "description": "",
          "arguments": [
            {
              "name": "otherRange",
              "description": "A {Range} or range-compatible {Array}. ",
              "type": "Range",
              "isOptional": false
            }
          ],
          "returnValues": [
            {
              "type": "Boolean",
              "description": "Returns a {Boolean} indicating whether this range starts and ends on\nthe same row as the argument."
            }
          ]
        },
        {
          "name": "intersectsWith",
          "sectionName": "Comparison",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/range.coffee#L256",
          "visibility": "Public",
          "summary": "Determines whether this range intersects with the argument.",
          "description": "Determines whether this range intersects with the argument.",
          "arguments": [
            {
              "name": "otherRange",
              "description": "A {Range} or range-compatible {Array}",
              "type": "Range",
              "isOptional": false
            },
            {
              "name": "exclusive",
              "description": "{Boolean} indicating whether to exclude endpoints   when testing for intersection. Defaults to `false`.",
              "type": "Boolean",
              "isOptional": true
            }
          ],
          "returnValues": [
            {
              "type": "Boolean",
              "description": "Returns a {Boolean}."
            }
          ]
        },
        {
          "name": "containsRange",
          "sectionName": "Comparison",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/range.coffee#L268",
          "visibility": "Public",
          "summary": "",
          "description": "",
          "arguments": [
            {
              "name": "otherRange",
              "description": "A {Range} or range-compatible {Array}",
              "type": "Range",
              "isOptional": false
            },
            {
              "name": "exclusive",
              "description": "A boolean value including that the containment should be exclusive of endpoints. Defaults to false. ",
              "type": null,
              "isOptional": false
            }
          ],
          "returnValues": [
            {
              "type": "Boolean",
              "description": "Returns a {Boolean} indicating whether this range contains the given\nrange."
            }
          ]
        },
        {
          "name": "containsPoint",
          "sectionName": "Comparison",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/range.coffee#L278",
          "visibility": "Public",
          "summary": "",
          "description": "",
          "arguments": [
            {
              "name": "point",
              "description": "A {Point} or point-compatible {Array}",
              "type": "Point",
              "isOptional": false
            },
            {
              "name": "exclusive",
              "description": "A boolean value including that the containment should be exclusive of endpoints. Defaults to false. ",
              "type": null,
              "isOptional": false
            }
          ],
          "returnValues": [
            {
              "type": "Boolean",
              "description": "Returns a {Boolean} indicating whether this range contains the given\npoint."
            }
          ]
        },
        {
          "name": "intersectsRow",
          "sectionName": "Comparison",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/range.coffee#L289",
          "visibility": "Public",
          "summary": "",
          "description": "",
          "arguments": [
            {
              "name": "row",
              "description": "Row {Number} ",
              "type": "Number",
              "isOptional": false
            }
          ],
          "returnValues": [
            {
              "type": "Boolean",
              "description": "Returns a {Boolean} indicating whether this range intersects the\ngiven row {Number}."
            }
          ]
        },
        {
          "name": "intersectsRowRange",
          "sectionName": "Comparison",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/range.coffee#L297",
          "visibility": "Public",
          "summary": "",
          "description": "",
          "arguments": [
            {
              "name": "startRow",
              "description": "{Number} start row",
              "type": "Number",
              "isOptional": false
            },
            {
              "name": "endRow",
              "description": "{Number} end row ",
              "type": "Number",
              "isOptional": false
            }
          ],
          "returnValues": [
            {
              "type": "Boolean",
              "description": "Returns a {Boolean} indicating whether this range intersects the\nrow range indicated by the given startRow and endRow {Number}s."
            }
          ]
        },
        {
          "name": "toString",
          "sectionName": "Conversion",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/range.coffee#L317",
          "visibility": "Public",
          "summary": "",
          "description": "",
          "returnValues": [
            {
              "type": null,
              "description": "Returns a string representation of the range."
            }
          ]
        }
      ],
      "classProperties": [],
      "instanceProperties": [
        {
          "name": "start",
          "sectionName": "Properties",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/range.coffee#L24",
          "visibility": "Public",
          "summary": "A {Point} representing the start of the {Range}. ",
          "description": "A {Point} representing the start of the {Range}. "
        },
        {
          "name": "end",
          "sectionName": "Properties",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/range.coffee#L27",
          "visibility": "Public",
          "summary": "A {Point} representing the end of the {Range}. ",
          "description": "A {Point} representing the end of the {Range}. "
        }
      ],
      "visibility": "Public",
      "summary": "Represents a region in a buffer in row/column coordinates.",
      "description": "Represents a region in a buffer in row/column coordinates.\n\nEvery public method that takes a range also accepts a *range-compatible*\n{Array}. This means a 2-element array containing {Point}s or point-compatible\narrays. So the following are equivalent:",
      "examples": [
        {
          "description": "",
          "lang": "coffee",
          "code": "new Range(new Point(0, 1), new Point(2, 3))\nnew Range([0, 1], [2, 3])\n[[0, 1], [2, 3]] # Range compatible array",
          "raw": "```coffee\nnew Range(new Point(0, 1), new Point(2, 3))\nnew Range([0, 1], [2, 3])\n[[0, 1], [2, 3]] # Range compatible array\n```"
        }
      ]
    },
    "TextBuffer": {
      "name": "TextBuffer",
      "filename": "src/text-buffer.coffee",
      "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/text-buffer.coffee#L111",
      "sections": [
        {
          "name": "Construction",
          "description": ""
        },
        {
          "name": "Event Subscription",
          "description": ""
        },
        {
          "name": "File Details",
          "description": ""
        },
        {
          "name": "Reading Text",
          "description": ""
        },
        {
          "name": "Mutating Text",
          "description": ""
        },
        {
          "name": "Markers",
          "description": ""
        },
        {
          "name": "History",
          "description": ""
        },
        {
          "name": "Search And Replace",
          "description": ""
        },
        {
          "name": "Buffer Range Details",
          "description": ""
        },
        {
          "name": "Buffer Operations",
          "description": ""
        },
        {
          "name": "Private Utility Methods",
          "description": ""
        }
      ],
      "classMethods": [
        {
          "name": "load",
          "sectionName": "Construction",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/text-buffer.coffee#L205",
          "visibility": "Public",
          "summary": "Create a new buffer backed by the given file path.",
          "description": "Create a new buffer backed by the given file path.",
          "arguments": [
            {
              "name": "source",
              "description": "Either a {String} path to a local file or (experimentally) a file {Object} as described by the {::setFile} method.",
              "type": "String",
              "isOptional": false
            },
            {
              "children": [
                {
                  "name": "encoding",
                  "description": "{String} The file's encoding.",
                  "type": "String",
                  "isOptional": true
                },
                {
                  "name": "shouldDestroyOnFileDelete",
                  "description": "A {Function} that returns a {Boolean} indicating whether the buffer should be destroyed if its file is deleted.",
                  "type": "Function",
                  "isOptional": true
                }
              ],
              "name": "params",
              "description": "An {Object} with the following properties:",
              "type": "Object",
              "isOptional": false
            }
          ],
          "returnValues": [
            {
              "type": "Promise",
              "description": "Returns a {Promise} that resolves with a {TextBuffer} instance."
            }
          ]
        },
        {
          "name": "loadSync",
          "sectionName": "Construction",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/text-buffer.coffee#L228",
          "visibility": "Public",
          "summary": "Create a new buffer backed by the given file path. For better\nperformance, use {TextBuffer.load} instead.",
          "description": "Create a new buffer backed by the given file path. For better\nperformance, use {TextBuffer.load} instead.",
          "arguments": [
            {
              "name": "filePath",
              "description": "The {String} file path.",
              "type": "String",
              "isOptional": false
            },
            {
              "children": [
                {
                  "name": "encoding",
                  "description": "{String} The file's encoding.",
                  "type": "String",
                  "isOptional": true
                },
                {
                  "name": "shouldDestroyOnFileDelete",
                  "description": "A {Function} that returns a {Boolean} indicating whether the buffer should be destroyed if its file is deleted.",
                  "type": "Function",
                  "isOptional": true
                }
              ],
              "name": "params",
              "description": "An {Object} with the following properties:",
              "type": "Object",
              "isOptional": false
            }
          ],
          "returnValues": [
            {
              "type": "TextBuffer",
              "description": "Returns a {TextBuffer} instance."
            }
          ]
        },
        {
          "name": "deserialize",
          "sectionName": "Construction",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/text-buffer.coffee#L244",
          "visibility": "Public",
          "summary": "Restore a {TextBuffer} based on an earlier state created using\nthe {TextBuffer::serialize} method.",
          "description": "Restore a {TextBuffer} based on an earlier state created using\nthe {TextBuffer::serialize} method.",
          "arguments": [
            {
              "name": "params",
              "description": "An {Object} returned from {TextBuffer::serialize}",
              "type": "Object",
              "isOptional": false
            }
          ],
          "returnValues": [
            {
              "type": "Promise",
              "description": "Returns a {Promise} that resolves with a {TextBuffer} instance."
            }
          ]
        }
      ],
      "instanceMethods": [
        {
          "name": "constructor",
          "sectionName": "Construction",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/text-buffer.coffee#L146",
          "visibility": "Public",
          "summary": "Create a new buffer with the given params.",
          "description": "Create a new buffer with the given params.",
          "arguments": [
            {
              "children": [
                {
                  "name": "text",
                  "description": "The initial {String} text of the buffer.",
                  "type": "String",
                  "isOptional": false
                },
                {
                  "name": "shouldDestroyOnFileDelete",
                  "description": "A {Function} that returns a {Boolean} indicating whether the buffer should be destroyed if its file is deleted. ",
                  "type": "Function",
                  "isOptional": false
                }
              ],
              "name": "params",
              "description": "{Object} or {String} of text",
              "type": "Object",
              "isOptional": false
            }
          ]
        },
        {
          "name": "onWillChange",
          "sectionName": "Event Subscription",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/text-buffer.coffee#L343",
          "visibility": "Public",
          "summary": "Invoke the given callback synchronously _before_ the content of the\nbuffer changes.",
          "description": "Invoke the given callback synchronously _before_ the content of the\nbuffer changes.\n\nBecause observers are invoked synchronously, it's important not to perform\nany expensive operations via this method.",
          "arguments": [
            {
              "name": "callback",
              "description": "{Function} to be called when the buffer changes.",
              "type": "Function",
              "isOptional": false
            }
          ],
          "returnValues": [
            {
              "type": "Disposable",
              "description": "Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."
            }
          ]
        },
        {
          "name": "onDidChange",
          "sectionName": "Event Subscription",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/text-buffer.coffee#L366",
          "visibility": "Public",
          "summary": "Invoke the given callback synchronously when a transaction finishes\nwith a list of all the changes in the transaction.",
          "description": "Invoke the given callback synchronously when a transaction finishes\nwith a list of all the changes in the transaction.",
          "arguments": [
            {
              "children": [
                {
                  "children": [
                    {
                      "name": "oldRange",
                      "description": "The smallest combined {Range} containing all of the old text.",
                      "type": "Range",
                      "isOptional": false
                    },
                    {
                      "name": "newRange",
                      "description": "The smallest combined {Range} containing all of the new text.",
                      "type": "Range",
                      "isOptional": false
                    },
                    {
                      "children": [
                        {
                          "name": "oldRange",
                          "description": "The {Range} of the deleted text in the contents of the buffer as it existed *before* the batch of changes reported by this event.",
                          "type": "Range",
                          "isOptional": false
                        },
                        {
                          "name": "newRange",
                          "description": "The {Range} of the inserted text in the current contents of the buffer.",
                          "type": "Range",
                          "isOptional": false
                        },
                        {
                          "name": "oldText",
                          "description": "A {String} representing the deleted text.",
                          "type": "String",
                          "isOptional": false
                        },
                        {
                          "name": "newText",
                          "description": "A {String} representing the inserted text.",
                          "type": "String",
                          "isOptional": false
                        }
                      ],
                      "name": "changes",
                      "description": "{Array} of {Object}s summarizing the aggregated changes that occurred during the transaction. See *Working With Aggregated Changes* in the description of the {TextBuffer} class for details.",
                      "type": "Array",
                      "isOptional": false
                    }
                  ],
                  "name": "event",
                  "description": "{Object} with the following keys:",
                  "type": "Object",
                  "isOptional": false
                }
              ],
              "name": "callback",
              "description": "{Function} to be called when a transaction in which textual changes occurred is completed.",
              "type": "Function",
              "isOptional": false
            }
          ],
          "returnValues": [
            {
              "type": "Disposable",
              "description": "Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."
            }
          ]
        },
        {
          "name": "onDidChangeText",
          "sectionName": "Event Subscription",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/text-buffer.coffee#L370",
          "visibility": "Public",
          "summary": "This is now identical to {onDidChange}. ",
          "description": "This is now identical to {onDidChange}. "
        },
        {
          "name": "onDidStopChanging",
          "sectionName": "Event Subscription",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/text-buffer.coffee#L394",
          "visibility": "Public",
          "summary": "Invoke the given callback asynchronously following one or more\nchanges after {::getStoppedChangingDelay} milliseconds elapse without an\nadditional change.",
          "description": "Invoke the given callback asynchronously following one or more\nchanges after {::getStoppedChangingDelay} milliseconds elapse without an\nadditional change.\n\nThis method can be used to perform potentially expensive operations that\ndon't need to be performed synchronously. If you need to run your callback\nsynchronously, use {::onDidChange} instead.",
          "arguments": [
            {
              "children": [
                {
                  "children": [
                    {
                      "children": [
                        {
                          "name": "oldRange",
                          "description": "The {Range} of the deleted text in the contents of the buffer as it existed *before* the batch of changes reported by this event.",
                          "type": "Range",
                          "isOptional": false
                        },
                        {
                          "name": "newRange",
                          "description": "The {Range} of the inserted text in the current contents of the buffer.",
                          "type": "Range",
                          "isOptional": false
                        },
                        {
                          "name": "oldText",
                          "description": "A {String} representing the deleted text.",
                          "type": "String",
                          "isOptional": false
                        },
                        {
                          "name": "newText",
                          "description": "A {String} representing the inserted text.",
                          "type": "String",
                          "isOptional": false
                        }
                      ],
                      "name": "changes",
                      "description": "An {Array} containing {Object}s summarizing the aggregated changes. See *Working With Aggregated Changes* in the description of the {TextBuffer} class for details.",
                      "type": "Array",
                      "isOptional": false
                    }
                  ],
                  "name": "event",
                  "description": "{Object} with the following keys:",
                  "type": "Object",
                  "isOptional": false
                }
              ],
              "name": "callback",
              "description": "{Function} to be called when the buffer stops changing.",
              "type": "Function",
              "isOptional": false
            }
          ],
          "returnValues": [
            {
              "type": "Disposable",
              "description": "Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."
            }
          ]
        },
        {
          "name": "onDidConflict",
          "sectionName": "Event Subscription",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/text-buffer.coffee#L403",
          "visibility": "Public",
          "summary": "Invoke the given callback when the in-memory contents of the\nbuffer become in conflict with the contents of the file on disk.",
          "description": "Invoke the given callback when the in-memory contents of the\nbuffer become in conflict with the contents of the file on disk.",
          "arguments": [
            {
              "name": "callback",
              "description": "{Function} to be called when the buffer enters conflict.",
              "type": "Function",
              "isOptional": false
            }
          ],
          "returnValues": [
            {
              "type": "Disposable",
              "description": "Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."
            }
          ]
        },
        {
          "name": "onDidChangeModified",
          "sectionName": "Event Subscription",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/text-buffer.coffee#L412",
          "visibility": "Public",
          "summary": "Invoke the given callback if the value of {::isModified} changes.",
          "description": "Invoke the given callback if the value of {::isModified} changes.",
          "arguments": [
            {
              "children": [
                {
                  "name": "modified",
                  "description": "{Boolean} indicating whether the buffer is modified.",
                  "type": "Boolean",
                  "isOptional": false
                }
              ],
              "name": "callback",
              "description": "{Function} to be called when {::isModified} changes.",
              "type": "Function",
              "isOptional": false
            }
          ],
          "returnValues": [
            {
              "type": "Disposable",
              "description": "Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."
            }
          ]
        },
        {
          "name": "onDidUpdateMarkers",
          "sectionName": "Event Subscription",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/text-buffer.coffee#L433",
          "visibility": "Public",
          "summary": "Invoke the given callback when all marker `::onDidChange`\nobservers have been notified following a change to the buffer.",
          "description": "Invoke the given callback when all marker `::onDidChange`\nobservers have been notified following a change to the buffer.\n\nThe order of events following a buffer change is as follows:\n\n* The text of the buffer is changed\n* All markers are updated accordingly, but their `::onDidChange` observers\n  are not notified.\n* `TextBuffer::onDidChange` observers are notified.\n* `Marker::onDidChange` observers are notified.\n* `TextBuffer::onDidUpdateMarkers` observers are notified.\n\nBasically, this method gives you a way to take action after both a buffer\nchange and all associated marker changes.",
          "arguments": [
            {
              "name": "callback",
              "description": "{Function} to be called after markers are updated.",
              "type": "Function",
              "isOptional": false
            }
          ],
          "returnValues": [
            {
              "type": "Disposable",
              "description": "Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."
            }
          ]
        },
        {
          "name": "onDidCreateMarker",
          "sectionName": "Event Subscription",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/text-buffer.coffee#L442",
          "visibility": "Public",
          "summary": "Invoke the given callback when a marker is created.",
          "description": "Invoke the given callback when a marker is created.",
          "arguments": [
            {
              "children": [
                {
                  "name": "marker",
                  "description": "{Marker} that was created.",
                  "type": "Marker",
                  "isOptional": false
                }
              ],
              "name": "callback",
              "description": "{Function} to be called when a marker is created.",
              "type": "Function",
              "isOptional": false
            }
          ],
          "returnValues": [
            {
              "type": "Disposable",
              "description": "Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."
            }
          ]
        },
        {
          "name": "onDidChangePath",
          "sectionName": "Event Subscription",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/text-buffer.coffee#L451",
          "visibility": "Public",
          "summary": "Invoke the given callback when the value of {::getPath} changes.",
          "description": "Invoke the given callback when the value of {::getPath} changes.",
          "arguments": [
            {
              "children": [
                {
                  "name": "path",
                  "description": "{String} representing the buffer's current path on disk.",
                  "type": "String",
                  "isOptional": false
                }
              ],
              "name": "callback",
              "description": "{Function} to be called when the path changes.",
              "type": "Function",
              "isOptional": false
            }
          ],
          "returnValues": [
            {
              "type": "Disposable",
              "description": "Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."
            }
          ]
        },
        {
          "name": "onDidChangeEncoding",
          "sectionName": "Event Subscription",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/text-buffer.coffee#L460",
          "visibility": "Public",
          "summary": "Invoke the given callback when the value of {::getEncoding} changes.",
          "description": "Invoke the given callback when the value of {::getEncoding} changes.",
          "arguments": [
            {
              "children": [
                {
                  "name": "encoding",
                  "description": "{String} character set encoding of the buffer.",
                  "type": "String",
                  "isOptional": false
                }
              ],
              "name": "callback",
              "description": "{Function} to be called when the encoding changes.",
              "type": "Function",
              "isOptional": false
            }
          ],
          "returnValues": [
            {
              "type": "Disposable",
              "description": "Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."
            }
          ]
        },
        {
          "name": "onWillSave",
          "sectionName": "Event Subscription",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/text-buffer.coffee#L469",
          "visibility": "Public",
          "summary": "Invoke the given callback before the buffer is saved to disk.",
          "description": "Invoke the given callback before the buffer is saved to disk.",
          "arguments": [
            {
              "name": "callback",
              "description": "{Function} to be called before the buffer is saved. If this function returns a {Promise}, then the buffer will not be saved until the promise resolves.",
              "type": "Function",
              "isOptional": false
            }
          ],
          "returnValues": [
            {
              "type": "Disposable",
              "description": "Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."
            }
          ]
        },
        {
          "name": "onDidSave",
          "sectionName": "Event Subscription",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/text-buffer.coffee#L479",
          "visibility": "Public",
          "summary": "Invoke the given callback after the buffer is saved to disk.",
          "description": "Invoke the given callback after the buffer is saved to disk.",
          "arguments": [
            {
              "children": [
                {
                  "children": [
                    {
                      "name": "path",
                      "description": "The path to which the buffer was saved.",
                      "type": null,
                      "isOptional": false
                    }
                  ],
                  "name": "event",
                  "description": "{Object} with the following keys:",
                  "type": "Object",
                  "isOptional": false
                }
              ],
              "name": "callback",
              "description": "{Function} to be called after the buffer is saved.",
              "type": "Function",
              "isOptional": false
            }
          ],
          "returnValues": [
            {
              "type": "Disposable",
              "description": "Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."
            }
          ]
        },
        {
          "name": "onDidDelete",
          "sectionName": "Event Subscription",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/text-buffer.coffee#L488",
          "visibility": "Public",
          "summary": "Invoke the given callback after the file backing the buffer is\ndeleted.",
          "description": "Invoke the given callback after the file backing the buffer is\ndeleted.",
          "arguments": [
            {
              "name": "callback",
              "description": "{Function} to be called after the buffer is deleted.",
              "type": "Function",
              "isOptional": false
            }
          ],
          "returnValues": [
            {
              "type": "Disposable",
              "description": "Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."
            }
          ]
        },
        {
          "name": "onWillReload",
          "sectionName": "Event Subscription",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/text-buffer.coffee#L497",
          "visibility": "Public",
          "summary": "Invoke the given callback before the buffer is reloaded from the\ncontents of its file on disk.",
          "description": "Invoke the given callback before the buffer is reloaded from the\ncontents of its file on disk.",
          "arguments": [
            {
              "name": "callback",
              "description": "{Function} to be called before the buffer is reloaded.",
              "type": "Function",
              "isOptional": false
            }
          ],
          "returnValues": [
            {
              "type": "Disposable",
              "description": "Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."
            }
          ]
        },
        {
          "name": "onDidReload",
          "sectionName": "Event Subscription",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/text-buffer.coffee#L506",
          "visibility": "Public",
          "summary": "Invoke the given callback after the buffer is reloaded from the\ncontents of its file on disk.",
          "description": "Invoke the given callback after the buffer is reloaded from the\ncontents of its file on disk.",
          "arguments": [
            {
              "name": "callback",
              "description": "{Function} to be called after the buffer is reloaded.",
              "type": "Function",
              "isOptional": false
            }
          ],
          "returnValues": [
            {
              "type": "Disposable",
              "description": "Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."
            }
          ]
        },
        {
          "name": "onDidDestroy",
          "sectionName": "Event Subscription",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/text-buffer.coffee#L514",
          "visibility": "Public",
          "summary": "Invoke the given callback when the buffer is destroyed.",
          "description": "Invoke the given callback when the buffer is destroyed.",
          "arguments": [
            {
              "name": "callback",
              "description": "{Function} to be called when the buffer is destroyed.",
              "type": "Function",
              "isOptional": false
            }
          ],
          "returnValues": [
            {
              "type": "Disposable",
              "description": "Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."
            }
          ]
        },
        {
          "name": "onWillThrowWatchError",
          "sectionName": "Event Subscription",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/text-buffer.coffee#L527",
          "visibility": "Public",
          "summary": "Invoke the given callback when there is an error in watching the\nfile.",
          "description": "Invoke the given callback when there is an error in watching the\nfile.",
          "arguments": [
            {
              "children": [
                {
                  "children": [
                    {
                      "name": "error",
                      "description": "{Object} the error object",
                      "type": "Object",
                      "isOptional": false
                    },
                    {
                      "name": "handle",
                      "description": "{Function} call this to indicate you have handled the error. The error will not be thrown if this function is called.",
                      "type": "Function",
                      "isOptional": false
                    }
                  ],
                  "name": "errorObject",
                  "description": "{Object}",
                  "type": "Object",
                  "isOptional": false
                }
              ],
              "name": "callback",
              "description": "{Function} callback",
              "type": "Function",
              "isOptional": false
            }
          ],
          "returnValues": [
            {
              "type": "Disposable",
              "description": "Returns a {Disposable} on which `.dispose()` can be called to unsubscribe."
            }
          ]
        },
        {
          "name": "getStoppedChangingDelay",
          "sectionName": "Event Subscription",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/text-buffer.coffee#L534",
          "visibility": "Public",
          "summary": "Get the number of milliseconds that will elapse without a change\nbefore {::onDidStopChanging} observers are invoked following a change.",
          "description": "Get the number of milliseconds that will elapse without a change\nbefore {::onDidStopChanging} observers are invoked following a change.",
          "returnValues": [
            {
              "type": "Number",
              "description": "Returns a {Number}."
            }
          ]
        },
        {
          "name": "isModified",
          "sectionName": "File Details",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/text-buffer.coffee#L546",
          "visibility": "Public",
          "summary": "Determine if the in-memory contents of the buffer differ from its\ncontents on disk.",
          "description": "Determine if the in-memory contents of the buffer differ from its\ncontents on disk.\n\nIf the buffer is unsaved, always returns `true` unless the buffer is empty.",
          "returnValues": [
            {
              "type": "Boolean",
              "description": "Returns a {Boolean}."
            }
          ]
        },
        {
          "name": "isInConflict",
          "sectionName": "File Details",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/text-buffer.coffee#L556",
          "visibility": "Public",
          "summary": "Determine if the in-memory contents of the buffer conflict with the\non-disk contents of its associated file.",
          "description": "Determine if the in-memory contents of the buffer conflict with the\non-disk contents of its associated file.",
          "returnValues": [
            {
              "type": "Boolean",
              "description": "Returns a {Boolean}."
            }
          ]
        },
        {
          "name": "getPath",
          "sectionName": "File Details",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/text-buffer.coffee#L561",
          "visibility": "Public",
          "summary": "Get the path of the associated file.",
          "description": "Get the path of the associated file.",
          "returnValues": [
            {
              "type": "String",
              "description": "Returns a {String}."
            }
          ]
        },
        {
          "name": "setPath",
          "sectionName": "File Details",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/text-buffer.coffee#L567",
          "visibility": "Public",
          "summary": "Set the path for the buffer's associated file.",
          "description": "Set the path for the buffer's associated file.",
          "arguments": [
            {
              "name": "filePath",
              "description": "A {String} representing the new file path ",
              "type": "String",
              "isOptional": false
            }
          ]
        },
        {
          "name": "setEncoding",
          "sectionName": "File Details",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/text-buffer.coffee#L599",
          "visibility": "Public",
          "summary": "Sets the character set encoding for this buffer.",
          "description": "Sets the character set encoding for this buffer.",
          "arguments": [
            {
              "name": "encoding",
              "description": "The {String} encoding to use (default: 'utf8'). ",
              "type": "String",
              "isOptional": false
            }
          ]
        },
        {
          "name": "getEncoding",
          "sectionName": "File Details",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/text-buffer.coffee#L613",
          "visibility": "Public",
          "summary": "",
          "description": "",
          "returnValues": [
            {
              "type": "String",
              "description": "Returns the {String} encoding of this buffer."
            }
          ]
        },
        {
          "name": "getUri",
          "sectionName": "File Details",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/text-buffer.coffee#L624",
          "visibility": "Public",
          "summary": "Get the path of the associated file.",
          "description": "Get the path of the associated file.",
          "returnValues": [
            {
              "type": "String",
              "description": "Returns a {String}."
            }
          ]
        },
        {
          "name": "isEmpty",
          "sectionName": "Reading Text",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/text-buffer.coffee#L643",
          "visibility": "Public",
          "summary": "Determine whether the buffer is empty.",
          "description": "Determine whether the buffer is empty.",
          "returnValues": [
            {
              "type": "Boolean",
              "description": "Returns a {Boolean}."
            }
          ]
        },
        {
          "name": "getText",
          "sectionName": "Reading Text",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/text-buffer.coffee#L648",
          "visibility": "Public",
          "summary": "Get the entire text of the buffer.",
          "description": "Get the entire text of the buffer.",
          "returnValues": [
            {
              "type": "String",
              "description": "Returns a {String}."
            }
          ]
        },
        {
          "name": "getTextInRange",
          "sectionName": "Reading Text",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/text-buffer.coffee#L655",
          "visibility": "Public",
          "summary": "Get the text in a range.",
          "description": "Get the text in a range.",
          "arguments": [
            {
              "name": "range",
              "description": "A {Range}",
              "type": "Range",
              "isOptional": false
            }
          ],
          "returnValues": [
            {
              "type": "String",
              "description": "Returns a {String}"
            }
          ]
        },
        {
          "name": "getLines",
          "sectionName": "Reading Text",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/text-buffer.coffee#L660",
          "visibility": "Public",
          "summary": "Get the text of all lines in the buffer, without their line endings.",
          "description": "Get the text of all lines in the buffer, without their line endings.",
          "returnValues": [
            {
              "type": "Array",
              "description": "Returns an {Array} of {String}s."
            }
          ]
        },
        {
          "name": "getLastLine",
          "sectionName": "Reading Text",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/text-buffer.coffee#L666",
          "visibility": "Public",
          "summary": "Get the text of the last line of the buffer, without its line\nending.",
          "description": "Get the text of the last line of the buffer, without its line\nending.",
          "returnValues": [
            {
              "type": "String",
              "description": "Returns a {String}."
            }
          ]
        },
        {
          "name": "lineForRow",
          "sectionName": "Reading Text",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/text-buffer.coffee#L674",
          "visibility": "Public",
          "summary": "Get the text of the line at the given row, without its line ending.",
          "description": "Get the text of the line at the given row, without its line ending.",
          "arguments": [
            {
              "name": "row",
              "description": "A {Number} representing a 0-indexed row.",
              "type": "Number",
              "isOptional": false
            }
          ],
          "returnValues": [
            {
              "type": "String",
              "description": "Returns a {String}."
            }
          ]
        },
        {
          "name": "lineEndingForRow",
          "sectionName": "Reading Text",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/text-buffer.coffee#L683",
          "visibility": "Public",
          "summary": "Get the line ending for the given 0-indexed row.",
          "description": "Get the line ending for the given 0-indexed row.",
          "arguments": [
            {
              "name": "row",
              "description": "A {Number} indicating the row.",
              "type": "Number",
              "isOptional": false
            }
          ],
          "returnValues": [
            {
              "type": "String",
              "description": "Returns a {String}. The returned newline is represented as a literal string:\n`'\\n'`, `'\\r\\n'`, or `''` for the last line of the buffer, which\ndoesn't end in a newline."
            }
          ]
        },
        {
          "name": "lineLengthForRow",
          "sectionName": "Reading Text",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/text-buffer.coffee#L691",
          "visibility": "Public",
          "summary": "Get the length of the line for the given 0-indexed row, without its\nline ending.",
          "description": "Get the length of the line for the given 0-indexed row, without its\nline ending.",
          "arguments": [
            {
              "name": "row",
              "description": "A {Number} indicating the row.",
              "type": "Number",
              "isOptional": false
            }
          ],
          "returnValues": [
            {
              "type": "Number",
              "description": "Returns a {Number}."
            }
          ]
        },
        {
          "name": "isRowBlank",
          "sectionName": "Reading Text",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/text-buffer.coffee#L698",
          "visibility": "Public",
          "summary": "Determine if the given row contains only whitespace.",
          "description": "Determine if the given row contains only whitespace.",
          "arguments": [
            {
              "name": "row",
              "description": "A {Number} representing a 0-indexed row.",
              "type": "Number",
              "isOptional": false
            }
          ],
          "returnValues": [
            {
              "type": "Boolean",
              "description": "Returns a {Boolean}."
            }
          ]
        },
        {
          "name": "previousNonBlankRow",
          "sectionName": "Reading Text",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/text-buffer.coffee#L706",
          "visibility": "Public",
          "summary": "Given a row, find the first preceding row that's not blank.",
          "description": "Given a row, find the first preceding row that's not blank.",
          "arguments": [
            {
              "name": "startRow",
              "description": "A {Number} identifying the row to start checking at.",
              "type": "Number",
              "isOptional": false
            }
          ],
          "returnValues": [
            {
              "type": "Number",
              "description": "Returns a {Number} or `null` if there's no preceding non-blank row."
            }
          ]
        },
        {
          "name": "nextNonBlankRow",
          "sectionName": "Reading Text",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/text-buffer.coffee#L719",
          "visibility": "Public",
          "summary": "Given a row, find the next row that's not blank.",
          "description": "Given a row, find the next row that's not blank.",
          "arguments": [
            {
              "name": "startRow",
              "description": "A {Number} identifying the row to start checking at.",
              "type": "Number",
              "isOptional": false
            }
          ],
          "returnValues": [
            {
              "type": "Number",
              "description": "Returns a {Number} or `null` if there's no next non-blank row."
            }
          ]
        },
        {
          "name": "setText",
          "sectionName": "Mutating Text",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/text-buffer.coffee#L735",
          "visibility": "Public",
          "summary": "Replace the entire contents of the buffer with the given text.",
          "description": "Replace the entire contents of the buffer with the given text.",
          "arguments": [
            {
              "name": "text",
              "description": "A {String}",
              "type": "String",
              "isOptional": false
            }
          ],
          "returnValues": [
            {
              "type": "Range",
              "description": "Returns a {Range} spanning the new buffer contents."
            }
          ]
        },
        {
          "name": "setTextViaDiff",
          "sectionName": "Mutating Text",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/text-buffer.coffee#L742",
          "visibility": "Public",
          "summary": "Replace the current buffer contents by applying a diff based on the\ngiven text.",
          "description": "Replace the current buffer contents by applying a diff based on the\ngiven text.",
          "arguments": [
            {
              "name": "text",
              "description": "A {String} containing the new buffer contents. ",
              "type": "String",
              "isOptional": false
            }
          ]
        },
        {
          "name": "setTextInRange",
          "sectionName": "Mutating Text",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/text-buffer.coffee#L790",
          "visibility": "Public",
          "summary": "Set the text in the given range.",
          "description": "Set the text in the given range.",
          "arguments": [
            {
              "name": "range",
              "description": "A {Range}",
              "type": "Range",
              "isOptional": false
            },
            {
              "name": "text",
              "description": "A {String}",
              "type": "String",
              "isOptional": false
            },
            {
              "children": [
                {
                  "name": "normalizeLineEndings",
                  "description": "{Boolean} (default: true)",
                  "type": "Boolean",
                  "isOptional": true
                },
                {
                  "name": "undo",
                  "description": "{String} 'skip' will skip the undo system",
                  "type": "String",
                  "isOptional": true
                }
              ],
              "name": "options",
              "description": "{Object}",
              "type": "Object",
              "isOptional": true
            }
          ],
          "returnValues": [
            {
              "type": "Range",
              "description": "Returns the {Range} of the inserted text."
            }
          ]
        },
        {
          "name": "insert",
          "sectionName": "Mutating Text",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/text-buffer.coffee#L831",
          "visibility": "Public",
          "summary": "Insert text at the given position.",
          "description": "Insert text at the given position.",
          "arguments": [
            {
              "name": "position",
              "description": "A {Point} representing the insertion location. The position is clipped before insertion.",
              "type": "Point",
              "isOptional": false
            },
            {
              "name": "text",
              "description": "A {String} representing the text to insert.",
              "type": "String",
              "isOptional": false
            },
            {
              "children": [
                {
                  "name": "normalizeLineEndings",
                  "description": "{Boolean} (default: true)",
                  "type": "Boolean",
                  "isOptional": true
                },
                {
                  "name": "undo",
                  "description": "{String} 'skip' will skip the undo system",
                  "type": "String",
                  "isOptional": true
                }
              ],
              "name": "options",
              "description": "{Object}",
              "type": "Object",
              "isOptional": true
            }
          ],
          "returnValues": [
            {
              "type": "Range",
              "description": "Returns the {Range} of the inserted text."
            }
          ]
        },
        {
          "name": "append",
          "sectionName": "Mutating Text",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/text-buffer.coffee#L842",
          "visibility": "Public",
          "summary": "Append text to the end of the buffer.",
          "description": "Append text to the end of the buffer.",
          "arguments": [
            {
              "name": "text",
              "description": "A {String} representing the text text to append.",
              "type": "String",
              "isOptional": false
            },
            {
              "children": [
                {
                  "name": "normalizeLineEndings",
                  "description": "{Boolean} (default: true)",
                  "type": "Boolean",
                  "isOptional": true
                },
                {
                  "name": "undo",
                  "description": "{String} 'skip' will skip the undo system",
                  "type": "String",
                  "isOptional": true
                }
              ],
              "name": "options",
              "description": "{Object}",
              "type": "Object",
              "isOptional": true
            }
          ],
          "returnValues": [
            {
              "type": "Range",
              "description": "Returns the {Range} of the inserted text"
            }
          ]
        },
        {
          "name": "delete",
          "sectionName": "Mutating Text",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/text-buffer.coffee#L893",
          "visibility": "Public",
          "summary": "Delete the text in the given range.",
          "description": "Delete the text in the given range.",
          "arguments": [
            {
              "name": "range",
              "description": "A {Range} in which to delete. The range is clipped before deleting.",
              "type": "Range",
              "isOptional": false
            }
          ],
          "returnValues": [
            {
              "type": "Range",
              "description": "Returns an empty {Range} starting at the start of deleted range."
            }
          ]
        },
        {
          "name": "deleteRow",
          "sectionName": "Mutating Text",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/text-buffer.coffee#L901",
          "visibility": "Public",
          "summary": "Delete the line associated with a specified row.",
          "description": "Delete the line associated with a specified row.",
          "arguments": [
            {
              "name": "row",
              "description": "A {Number} representing the 0-indexed row to delete.",
              "type": "Number",
              "isOptional": false
            }
          ],
          "returnValues": [
            {
              "type": "Range",
              "description": "Returns the {Range} of the deleted text."
            }
          ]
        },
        {
          "name": "deleteRows",
          "sectionName": "Mutating Text",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/text-buffer.coffee#L913",
          "visibility": "Public",
          "summary": "Delete the lines associated with the specified row range.",
          "description": "Delete the lines associated with the specified row range.\n\nIf the row range is out of bounds, it will be clipped. If the startRow is\ngreater than the end row, they will be reordered.",
          "arguments": [
            {
              "name": "startRow",
              "description": "A {Number} representing the first row to delete.",
              "type": "Number",
              "isOptional": false
            },
            {
              "name": "endRow",
              "description": "A {Number} representing the last row to delete, inclusive.",
              "type": "Number",
              "isOptional": false
            }
          ],
          "returnValues": [
            {
              "type": "Range",
              "description": "Returns the {Range} of the deleted text."
            }
          ]
        },
        {
          "name": "addMarkerLayer",
          "sectionName": "Markers",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/text-buffer.coffee#L956",
          "visibility": "Public",
          "summary": "Create a layer to contain a set of related markers.",
          "description": "Create a layer to contain a set of related markers.",
          "arguments": [
            {
              "children": [
                {
                  "name": "maintainHistory",
                  "description": "A {Boolean} indicating whether or not the state of this layer should be restored on undo/redo operations. Defaults to `false`.",
                  "type": "Boolean",
                  "isOptional": false
                },
                {
                  "name": "persistent",
                  "description": "A {Boolean} indicating whether or not this marker layer should be serialized and deserialized along with the rest of the buffer. Defaults to `false`. If `true`, the marker layer's id will be maintained across the serialization boundary, allowing you to retrieve it via {::getMarkerLayer}.",
                  "type": "Boolean",
                  "isOptional": false
                }
              ],
              "name": "options",
              "description": "An object contaning the following keys:",
              "type": null,
              "isOptional": false
            }
          ],
          "returnValues": [
            {
              "type": "MarkerLayer",
              "description": "Returns a {MarkerLayer}."
            }
          ]
        },
        {
          "name": "getMarkerLayer",
          "sectionName": "Markers",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/text-buffer.coffee#L967",
          "visibility": "Public",
          "summary": "Get a {MarkerLayer} by id.",
          "description": "Get a {MarkerLayer} by id.",
          "arguments": [
            {
              "name": "id",
              "description": "The id of the marker layer to retrieve.",
              "type": null,
              "isOptional": false
            }
          ],
          "returnValues": [
            {
              "type": "MarkerLayer",
              "description": "Returns a {MarkerLayer} or `` if no layer exists with the given\nid."
            }
          ]
        },
        {
          "name": "getDefaultMarkerLayer",
          "sectionName": "Markers",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/text-buffer.coffee#L976",
          "visibility": "Public",
          "summary": "Get the default {MarkerLayer}.",
          "description": "Get the default {MarkerLayer}.\n\nAll marker APIs not tied to an explicit layer interact with this default\nlayer.",
          "returnValues": [
            {
              "type": "MarkerLayer",
              "description": "Returns a {MarkerLayer}."
            }
          ]
        },
        {
          "name": "markRange",
          "sectionName": "Markers",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/text-buffer.coffee#L1011",
          "visibility": "Public",
          "summary": "Create a marker with the given range in the default marker layer.\nThis marker will maintain its logical location as the buffer is changed, so\nif you mark a particular word, the marker will remain over that word even if\nthe word's location in the buffer changes.",
          "description": "Create a marker with the given range in the default marker layer.\nThis marker will maintain its logical location as the buffer is changed, so\nif you mark a particular word, the marker will remain over that word even if\nthe word's location in the buffer changes.",
          "arguments": [
            {
              "name": "range",
              "description": "A {Range} or range-compatible {Array}",
              "type": "Range",
              "isOptional": false
            },
            {
              "children": [
                {
                  "name": "reversed",
                  "description": "{Boolean} Creates the marker in a reversed orientation. (default: false)",
                  "type": "Boolean",
                  "isOptional": true
                },
                {
                  "name": "invalidate",
                  "description": "{String} Determines the rules by which changes to the buffer *invalidate* the marker. (default: 'overlap') It can be any of the following strategies, in order of fragility:\n* __never__: The marker is never marked as invalid. This is a good choice for\n  markers representing selections in an editor.\n* __surround__: The marker is invalidated by changes that completely surround it.\n* __overlap__: The marker is invalidated by changes that surround the\n  start or end of the marker. This is the default.\n* __inside__: The marker is invalidated by changes that extend into the\n  inside of the marker. Changes that end at the marker's start or\n  start at the marker's end do not invalidate the marker.\n* __touch__: The marker is invalidated by a change that touches the marked\n  region in any way, including changes that end at the marker's\n  start or start at the marker's end. This is the most fragile strategy.",
                  "type": "String",
                  "isOptional": true
                },
                {
                  "name": "exclusive",
                  "description": "{Boolean} indicating whether insertions at the start or end of the marked range should be interpreted as happening *outside* the marker. Defaults to `false`, except when using the `inside` invalidation strategy or when when the marker has no tail, in which case it defaults to true. Explicitly assigning this option overrides behavior in all circumstances.",
                  "type": "Boolean",
                  "isOptional": false
                }
              ],
              "name": "properties",
              "description": "A hash of key-value pairs to associate with the marker. There are also reserved property names that have marker-specific meaning.",
              "type": null,
              "isOptional": false
            }
          ],
          "returnValues": [
            {
              "type": "Marker",
              "description": "Returns a {Marker}."
            }
          ]
        },
        {
          "name": "markPosition",
          "sectionName": "Markers",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/text-buffer.coffee#L1040",
          "visibility": "Public",
          "summary": "Create a marker at the given position with no tail in the default\nmarker layer.",
          "description": "Create a marker at the given position with no tail in the default\nmarker layer.",
          "arguments": [
            {
              "name": "position",
              "description": "{Point} or point-compatible {Array}",
              "type": "Point",
              "isOptional": false
            },
            {
              "children": [
                {
                  "name": "invalidate",
                  "description": "{String} Determines the rules by which changes to the buffer *invalidate* the marker. (default: 'overlap') It can be any of the following strategies, in order of fragility:\n* __never__: The marker is never marked as invalid. This is a good choice for\n  markers representing selections in an editor.\n* __surround__: The marker is invalidated by changes that completely surround it.\n* __overlap__: The marker is invalidated by changes that surround the\n  start or end of the marker. This is the default.\n* __inside__: The marker is invalidated by changes that extend into the\n  inside of the marker. Changes that end at the marker's start or\n  start at the marker's end do not invalidate the marker.\n* __touch__: The marker is invalidated by a change that touches the marked\n  region in any way, including changes that end at the marker's\n  start or start at the marker's end. This is the most fragile strategy.",
                  "type": "String",
                  "isOptional": true
                },
                {
                  "name": "exclusive",
                  "description": "{Boolean} indicating whether insertions at the start or end of the marked range should be interpreted as happening *outside* the marker. Defaults to `false`, except when using the `inside` invalidation strategy or when when the marker has no tail, in which case it defaults to true. Explicitly assigning this option overrides behavior in all circumstances.",
                  "type": "Boolean",
                  "isOptional": false
                }
              ],
              "name": "options",
              "description": "An {Object} with the following keys:",
              "type": "Object",
              "isOptional": true
            }
          ],
          "returnValues": [
            {
              "type": "Marker",
              "description": "Returns a {Marker}."
            }
          ]
        },
        {
          "name": "getMarkers",
          "sectionName": "Markers",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/text-buffer.coffee#L1045",
          "visibility": "Public",
          "summary": "Get all existing markers on the default marker layer.",
          "description": "Get all existing markers on the default marker layer.",
          "returnValues": [
            {
              "type": "Array",
              "description": "Returns an {Array} of {Marker}s."
            }
          ]
        },
        {
          "name": "getMarker",
          "sectionName": "Markers",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/text-buffer.coffee#L1052",
          "visibility": "Public",
          "summary": "Get an existing marker by its id from the default marker layer.",
          "description": "Get an existing marker by its id from the default marker layer.",
          "arguments": [
            {
              "name": "id",
              "description": "{Number} id of the marker to retrieve",
              "type": "Number",
              "isOptional": false
            }
          ],
          "returnValues": [
            {
              "type": "Marker",
              "description": "Returns a {Marker}."
            }
          ]
        },
        {
          "name": "findMarkers",
          "sectionName": "Markers",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/text-buffer.coffee#L1075",
          "visibility": "Public",
          "summary": "Find markers conforming to the given parameters in the default\nmarker layer.",
          "description": "Find markers conforming to the given parameters in the default\nmarker layer.\n\nMarkers are sorted based on their position in the buffer. If two markers\nstart at the same position, the larger marker comes first.",
          "arguments": [
            {
              "children": [
                {
                  "name": "startPosition",
                  "description": "Only include markers that start at the given {Point}.",
                  "type": "Point",
                  "isOptional": false
                },
                {
                  "name": "endPosition",
                  "description": "Only include markers that end at the given {Point}.",
                  "type": "Point",
                  "isOptional": false
                },
                {
                  "name": "startsInRange",
                  "description": "Only include markers that start inside the given {Range}.",
                  "type": "Range",
                  "isOptional": false
                },
                {
                  "name": "endsInRange",
                  "description": "Only include markers that end inside the given {Range}.",
                  "type": "Range",
                  "isOptional": false
                },
                {
                  "name": "containsPoint",
                  "description": "Only include markers that contain the given {Point}, inclusive.",
                  "type": "Point",
                  "isOptional": false
                },
                {
                  "name": "containsRange",
                  "description": "Only include markers that contain the given {Range}, inclusive.",
                  "type": "Range",
                  "isOptional": false
                },
                {
                  "name": "startRow",
                  "description": "Only include markers that start at the given row {Number}.",
                  "type": "Number",
                  "isOptional": false
                },
                {
                  "name": "endRow",
                  "description": "Only include markers that end at the given row {Number}.",
                  "type": "Number",
                  "isOptional": false
                },
                {
                  "name": "intersectsRow",
                  "description": "Only include markers that intersect the given row {Number}.",
                  "type": "Number",
                  "isOptional": false
                }
              ],
              "name": "params",
              "description": "A hash of key-value pairs constraining the set of returned markers. You can query against custom marker properties by listing the desired key-value pairs here. In addition, the following keys are reserved and have special semantics:",
              "type": null,
              "isOptional": false
            }
          ],
          "returnValues": [
            {
              "type": "Array",
              "description": "Returns an {Array} of {Marker}s."
            }
          ]
        },
        {
          "name": "getMarkerCount",
          "sectionName": "Markers",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/text-buffer.coffee#L1080",
          "visibility": "Public",
          "summary": "Get the number of markers in the default marker layer.",
          "description": "Get the number of markers in the default marker layer.",
          "returnValues": [
            {
              "type": "Number",
              "description": "Returns a {Number}."
            }
          ]
        },
        {
          "name": "undo",
          "sectionName": "History",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/text-buffer.coffee#L1116",
          "visibility": "Public",
          "summary": "Undo the last operation. If a transaction is in progress, aborts it. ",
          "description": "Undo the last operation. If a transaction is in progress, aborts it. "
        },
        {
          "name": "redo",
          "sectionName": "History",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/text-buffer.coffee#L1132",
          "visibility": "Public",
          "summary": "Redo the last operation ",
          "description": "Redo the last operation "
        },
        {
          "name": "transact",
          "sectionName": "History",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/text-buffer.coffee#L1160",
          "visibility": "Public",
          "summary": "Batch multiple operations as a single undo/redo step.",
          "description": "Batch multiple operations as a single undo/redo step.\n\nAny group of operations that are logically grouped from the perspective of\nundoing and redoing should be performed in a transaction. If you want to\nabort the transaction, call {::abortTransaction} to terminate the function's\nexecution and revert any changes performed up to the abortion.",
          "arguments": [
            {
              "name": "groupingInterval",
              "description": "The {Number} of milliseconds for which this transaction should be considered 'open for grouping' after it begins. If a transaction with a positive `groupingInterval` is committed while the previous transaction is still open for grouping, the two transactions are merged with respect to undo and redo.",
              "type": "Number",
              "isOptional": true
            },
            {
              "name": "fn",
              "description": "A {Function} to call inside the transaction. ",
              "type": "Function",
              "isOptional": false
            }
          ]
        },
        {
          "name": "clearUndoStack",
          "sectionName": "History",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/text-buffer.coffee#L1190",
          "visibility": "Public",
          "summary": "Clear the undo stack. ",
          "description": "Clear the undo stack. "
        },
        {
          "name": "createCheckpoint",
          "sectionName": "History",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/text-buffer.coffee#L1196",
          "visibility": "Public",
          "summary": "Create a pointer to the current state of the buffer for use\nwith {::revertToCheckpoint} and {::groupChangesSinceCheckpoint}.",
          "description": "Create a pointer to the current state of the buffer for use\nwith {::revertToCheckpoint} and {::groupChangesSinceCheckpoint}.",
          "returnValues": [
            {
              "type": null,
              "description": "Returns a checkpoint value."
            }
          ]
        },
        {
          "name": "revertToCheckpoint",
          "sectionName": "History",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/text-buffer.coffee#L1208",
          "visibility": "Public",
          "summary": "Revert the buffer to the state it was in when the given\ncheckpoint was created.",
          "description": "Revert the buffer to the state it was in when the given\ncheckpoint was created.\n\nThe redo stack will be empty following this operation, so changes since the\ncheckpoint will be lost. If the given checkpoint is no longer present in the\nundo history, no changes will be made to the buffer and this method will\nreturn `false`.",
          "returnValues": [
            {
              "type": "Boolean",
              "description": "Returns a {Boolean} indicating whether the operation succeeded."
            }
          ]
        },
        {
          "name": "groupChangesSinceCheckpoint",
          "sectionName": "History",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/text-buffer.coffee#L1231",
          "visibility": "Public",
          "summary": "Group all changes since the given checkpoint into a single\ntransaction for purposes of undo/redo.",
          "description": "Group all changes since the given checkpoint into a single\ntransaction for purposes of undo/redo.\n\nIf the given checkpoint is no longer present in the undo history, no\ngrouping will be performed and this method will return `false`.",
          "returnValues": [
            {
              "type": "Boolean",
              "description": "Returns a {Boolean} indicating whether the operation succeeded."
            }
          ]
        },
        {
          "name": "getChangesSinceCheckpoint",
          "sectionName": "History",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/text-buffer.coffee#L1247",
          "visibility": "Public",
          "summary": "",
          "description": "\n\nIf the given checkpoint is no longer present in the undo history, this\nmethod will return an empty {Array}.",
          "returnValues": [
            {
              "type": null,
              "description": "Returns a list of changes since the given checkpoint."
            },
            {
              "type": "Array",
              "description": "Returns an {Array} of {Object}s with the following fields that summarize\n the aggregated changes since the checkpoint. See *Working With Aggregated\nChanges* in the description of the {TextBuffer} class for details.\n\n* `oldRange` The {Range} of the deleted text in the text as it existed when\n  the checkpoint was created.\n* `newRange`: The {Range} of the inserted text in the current text.\n* `oldText`: A {String} representing the deleted text.\n* `newText`: A {String} representing the inserted text."
            }
          ]
        },
        {
          "name": "scan",
          "sectionName": "Search And Replace",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/text-buffer.coffee#L1278",
          "visibility": "Public",
          "summary": "Scan regular expression matches in the entire buffer, calling the\ngiven iterator function on each match.",
          "description": "Scan regular expression matches in the entire buffer, calling the\ngiven iterator function on each match.\n\nIf you're programmatically modifying the results, you may want to try\n{::backwardsScan} to avoid tripping over your own changes.",
          "arguments": [
            {
              "name": "regex",
              "description": "A {RegExp} to search for.",
              "type": "RegExp",
              "isOptional": false
            },
            {
              "children": [
                {
                  "name": "leadingContextLineCount",
                  "description": "{Number} default `0`; The number of lines before the  matched line to include in the results object.",
                  "type": "Number",
                  "isOptional": false
                },
                {
                  "name": "trailingContextLineCount",
                  "description": "{Number} default `0`; The number of lines after the  matched line to include in the results object.",
                  "type": "Number",
                  "isOptional": false
                }
              ],
              "name": "options",
              "description": "{Object}",
              "type": "Object",
              "isOptional": true
            },
            {
              "children": [
                {
                  "name": "match",
                  "description": "The current regular expression match.",
                  "type": null,
                  "isOptional": false
                },
                {
                  "name": "matchText",
                  "description": "A {String} with the text of the match.",
                  "type": "String",
                  "isOptional": false
                },
                {
                  "name": "range",
                  "description": "The {Range} of the match.",
                  "type": "Range",
                  "isOptional": false
                },
                {
                  "name": "stop",
                  "description": "Call this {Function} to terminate the scan.",
                  "type": "Function",
                  "isOptional": false
                },
                {
                  "name": "replace",
                  "description": "Call this {Function} with a {String} to replace the match.",
                  "type": "Function",
                  "isOptional": false
                },
                {
                  "name": "leadingContextLines",
                  "description": "An {Array} with `leadingContextLineCount` lines before the match.",
                  "type": "Array",
                  "isOptional": false
                },
                {
                  "name": "trailingContextLines",
                  "description": "An {Array} with `trailingContextLineCount` lines after the match. ",
                  "type": "Array",
                  "isOptional": false
                }
              ],
              "name": "iterator",
              "description": "A {Function} that's called on each match with an {Object} containing the following keys:",
              "type": "Function",
              "isOptional": false
            }
          ]
        },
        {
          "name": "backwardsScan",
          "sectionName": "Search And Replace",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/text-buffer.coffee#L1303",
          "visibility": "Public",
          "summary": "Scan regular expression matches in the entire buffer in reverse\norder, calling the given iterator function on each match.",
          "description": "Scan regular expression matches in the entire buffer in reverse\norder, calling the given iterator function on each match.",
          "arguments": [
            {
              "name": "regex",
              "description": "A {RegExp} to search for.",
              "type": "RegExp",
              "isOptional": false
            },
            {
              "children": [
                {
                  "name": "leadingContextLineCount",
                  "description": "{Number} default `0`; The number of lines before the  matched line to include in the results object.",
                  "type": "Number",
                  "isOptional": false
                },
                {
                  "name": "trailingContextLineCount",
                  "description": "{Number} default `0`; The number of lines after the  matched line to include in the results object.",
                  "type": "Number",
                  "isOptional": false
                }
              ],
              "name": "options",
              "description": "{Object}",
              "type": "Object",
              "isOptional": true
            },
            {
              "children": [
                {
                  "name": "match",
                  "description": "The current regular expression match.",
                  "type": null,
                  "isOptional": false
                },
                {
                  "name": "matchText",
                  "description": "A {String} with the text of the match.",
                  "type": "String",
                  "isOptional": false
                },
                {
                  "name": "range",
                  "description": "The {Range} of the match.",
                  "type": "Range",
                  "isOptional": false
                },
                {
                  "name": "stop",
                  "description": "Call this {Function} to terminate the scan.",
                  "type": "Function",
                  "isOptional": false
                },
                {
                  "name": "replace",
                  "description": "Call this {Function} with a {String} to replace the match.",
                  "type": "Function",
                  "isOptional": false
                },
                {
                  "name": "leadingContextLines",
                  "description": "An {Array} with `leadingContextLineCount` lines before the match.",
                  "type": "Array",
                  "isOptional": false
                },
                {
                  "name": "trailingContextLines",
                  "description": "An {Array} with `trailingContextLineCount` lines after the match. ",
                  "type": "Array",
                  "isOptional": false
                }
              ],
              "name": "iterator",
              "description": "A {Function} that's called on each match with an {Object} containing the following keys:",
              "type": "Function",
              "isOptional": false
            }
          ]
        },
        {
          "name": "scanInRange",
          "sectionName": "Search And Replace",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/text-buffer.coffee#L1329",
          "visibility": "Public",
          "summary": "Scan regular expression matches in a given range , calling the given\niterator function on each match.",
          "description": "Scan regular expression matches in a given range , calling the given\niterator function on each match.",
          "arguments": [
            {
              "name": "regex",
              "description": "A {RegExp} to search for.",
              "type": "RegExp",
              "isOptional": false
            },
            {
              "name": "range",
              "description": "A {Range} in which to search.",
              "type": "Range",
              "isOptional": false
            },
            {
              "children": [
                {
                  "name": "leadingContextLineCount",
                  "description": "{Number} default `0`; The number of lines before the  matched line to include in the results object.",
                  "type": "Number",
                  "isOptional": false
                },
                {
                  "name": "trailingContextLineCount",
                  "description": "{Number} default `0`; The number of lines after the  matched line to include in the results object.",
                  "type": "Number",
                  "isOptional": false
                }
              ],
              "name": "options",
              "description": "{Object}",
              "type": "Object",
              "isOptional": true
            },
            {
              "children": [
                {
                  "name": "match",
                  "description": "The current regular expression match.",
                  "type": null,
                  "isOptional": false
                },
                {
                  "name": "matchText",
                  "description": "A {String} with the text of the match.",
                  "type": "String",
                  "isOptional": false
                },
                {
                  "name": "range",
                  "description": "The {Range} of the match.",
                  "type": "Range",
                  "isOptional": false
                },
                {
                  "name": "stop",
                  "description": "Call this {Function} to terminate the scan.",
                  "type": "Function",
                  "isOptional": false
                },
                {
                  "name": "replace",
                  "description": "Call this {Function} with a {String} to replace the match.",
                  "type": "Function",
                  "isOptional": false
                },
                {
                  "name": "leadingContextLines",
                  "description": "An {Array} with `leadingContextLineCount` lines before the match.",
                  "type": "Array",
                  "isOptional": false
                },
                {
                  "name": "trailingContextLines",
                  "description": "An {Array} with `trailingContextLineCount` lines after the match. ",
                  "type": "Array",
                  "isOptional": false
                }
              ],
              "name": "callback",
              "description": "A {Function} that's called on each match with an {Object} containing the following keys:",
              "type": "Function",
              "isOptional": false
            }
          ]
        },
        {
          "name": "backwardsScanInRange",
          "sectionName": "Search And Replace",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/text-buffer.coffee#L1371",
          "visibility": "Public",
          "summary": "Scan regular expression matches in a given range in reverse order,\ncalling the given iterator function on each match.",
          "description": "Scan regular expression matches in a given range in reverse order,\ncalling the given iterator function on each match.",
          "arguments": [
            {
              "name": "regex",
              "description": "A {RegExp} to search for.",
              "type": "RegExp",
              "isOptional": false
            },
            {
              "name": "range",
              "description": "A {Range} in which to search.",
              "type": "Range",
              "isOptional": false
            },
            {
              "children": [
                {
                  "name": "leadingContextLineCount",
                  "description": "{Number} default `0`; The number of lines before the  matched line to include in the results object.",
                  "type": "Number",
                  "isOptional": false
                },
                {
                  "name": "trailingContextLineCount",
                  "description": "{Number} default `0`; The number of lines after the  matched line to include in the results object.",
                  "type": "Number",
                  "isOptional": false
                }
              ],
              "name": "options",
              "description": "{Object}",
              "type": "Object",
              "isOptional": true
            },
            {
              "children": [
                {
                  "name": "match",
                  "description": "The current regular expression match.",
                  "type": null,
                  "isOptional": false
                },
                {
                  "name": "matchText",
                  "description": "A {String} with the text of the match.",
                  "type": "String",
                  "isOptional": false
                },
                {
                  "name": "range",
                  "description": "The {Range} of the match.",
                  "type": "Range",
                  "isOptional": false
                },
                {
                  "name": "stop",
                  "description": "Call this {Function} to terminate the scan.",
                  "type": "Function",
                  "isOptional": false
                },
                {
                  "name": "replace",
                  "description": "Call this {Function} with a {String} to replace the match. ",
                  "type": "Function",
                  "isOptional": false
                }
              ],
              "name": "iterator",
              "description": "A {Function} that's called on each match with an {Object} containing the following keys:",
              "type": "Function",
              "isOptional": false
            }
          ]
        },
        {
          "name": "replace",
          "sectionName": "Search And Replace",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/text-buffer.coffee#L1384",
          "visibility": "Public",
          "summary": "Replace all regular expression matches in the entire buffer.",
          "description": "Replace all regular expression matches in the entire buffer.",
          "arguments": [
            {
              "name": "regex",
              "description": "A {RegExp} representing the matches to be replaced.",
              "type": "RegExp",
              "isOptional": false
            },
            {
              "name": "replacementText",
              "description": "A {String} representing the text to replace each match.",
              "type": "String",
              "isOptional": false
            }
          ],
          "returnValues": [
            {
              "type": "Number",
              "description": "Returns a {Number} representing the number of replacements made."
            }
          ]
        },
        {
          "name": "getRange",
          "sectionName": "Buffer Range Details",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/text-buffer.coffee#L1495",
          "visibility": "Public",
          "summary": "Get the range spanning from `[0, 0]` to {::getEndPosition}.",
          "description": "Get the range spanning from `[0, 0]` to {::getEndPosition}.",
          "returnValues": [
            {
              "type": "Range",
              "description": "Returns a {Range}."
            }
          ]
        },
        {
          "name": "getLineCount",
          "sectionName": "Buffer Range Details",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/text-buffer.coffee#L1501",
          "visibility": "Public",
          "summary": "Get the number of lines in the buffer.",
          "description": "Get the number of lines in the buffer.",
          "returnValues": [
            {
              "type": "Number",
              "description": "Returns a {Number}."
            }
          ]
        },
        {
          "name": "getLastRow",
          "sectionName": "Buffer Range Details",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/text-buffer.coffee#L1506",
          "visibility": "Public",
          "summary": "Get the last 0-indexed row in the buffer.",
          "description": "Get the last 0-indexed row in the buffer.",
          "returnValues": [
            {
              "type": "Number",
              "description": "Returns a {Number}."
            }
          ]
        },
        {
          "name": "getFirstPosition",
          "sectionName": "Buffer Range Details",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/text-buffer.coffee#L1512",
          "visibility": "Public",
          "summary": "Get the first position in the buffer, which is always `[0, 0]`.",
          "description": "Get the first position in the buffer, which is always `[0, 0]`.",
          "returnValues": [
            {
              "type": "Point",
              "description": "Returns a {Point}."
            }
          ]
        },
        {
          "name": "getEndPosition",
          "sectionName": "Buffer Range Details",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/text-buffer.coffee#L1519",
          "visibility": "Public",
          "summary": "Get the maximal position in the buffer, where new text would be\nappended.",
          "description": "Get the maximal position in the buffer, where new text would be\nappended.",
          "returnValues": [
            {
              "type": "Point",
              "description": "Returns a {Point}."
            }
          ]
        },
        {
          "name": "getMaxCharacterIndex",
          "sectionName": "Buffer Range Details",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/text-buffer.coffee#L1524",
          "visibility": "Public",
          "summary": "Get the length of the buffer in characters.",
          "description": "Get the length of the buffer in characters.",
          "returnValues": [
            {
              "type": "Number",
              "description": "Returns a {Number}."
            }
          ]
        },
        {
          "name": "rangeForRow",
          "sectionName": "Buffer Range Details",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/text-buffer.coffee#L1535",
          "visibility": "Public",
          "summary": "Get the range for the given row",
          "description": "Get the range for the given row",
          "arguments": [
            {
              "name": "row",
              "description": "A {Number} representing a 0-indexed row.",
              "type": "Number",
              "isOptional": false
            },
            {
              "name": "includeNewline",
              "description": "A {Boolean} indicating whether or not to include the newline, which results in a range that extends to the start of the next line.",
              "type": "Boolean",
              "isOptional": false
            }
          ],
          "returnValues": [
            {
              "type": "Range",
              "description": "Returns a {Range}."
            }
          ]
        },
        {
          "name": "characterIndexForPosition",
          "sectionName": "Buffer Range Details",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/text-buffer.coffee#L1552",
          "visibility": "Public",
          "summary": "Convert a position in the buffer in row/column coordinates to an\nabsolute character offset, inclusive of line ending characters.",
          "description": "Convert a position in the buffer in row/column coordinates to an\nabsolute character offset, inclusive of line ending characters.\n\nThe position is clipped prior to translating.",
          "arguments": [
            {
              "name": "position",
              "description": "A {Point}.",
              "type": "Point",
              "isOptional": false
            }
          ],
          "returnValues": [
            {
              "type": "Number",
              "description": "Returns a {Number}."
            }
          ]
        },
        {
          "name": "positionForCharacterIndex",
          "sectionName": "Buffer Range Details",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/text-buffer.coffee#L1563",
          "visibility": "Public",
          "summary": "Convert an absolute character offset, inclusive of newlines, to a\nposition in the buffer in row/column coordinates.",
          "description": "Convert an absolute character offset, inclusive of newlines, to a\nposition in the buffer in row/column coordinates.\n\nThe offset is clipped prior to translating.",
          "arguments": [
            {
              "name": "offset",
              "description": "A {Number}.",
              "type": "Number",
              "isOptional": false
            }
          ],
          "returnValues": [
            {
              "type": "Point",
              "description": "Returns a {Point}."
            }
          ]
        },
        {
          "name": "clipRange",
          "sectionName": "Buffer Range Details",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/text-buffer.coffee#L1575",
          "visibility": "Public",
          "summary": "Clip the given range so it starts and ends at valid positions.",
          "description": "Clip the given range so it starts and ends at valid positions.\n\nFor example, the position `[1, 100]` is out of bounds if the line at row 1 is\nonly 10 characters long, and it would be clipped to `(1, 10)`.",
          "arguments": [
            {
              "name": "range",
              "description": "A {Range} or range-compatible {Array} to clip.",
              "type": "Range",
              "isOptional": false
            }
          ],
          "returnValues": [
            {
              "type": "Range",
              "description": "Returns the given {Range} if it is already in bounds, or a new clipped\n{Range} if the given range is out-of-bounds."
            }
          ]
        },
        {
          "name": "clipPosition",
          "sectionName": "Buffer Range Details",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/text-buffer.coffee#L1593",
          "visibility": "Public",
          "summary": "Clip the given point so it is at a valid position in the buffer.",
          "description": "Clip the given point so it is at a valid position in the buffer.\n\nFor example, the position (1, 100) is out of bounds if the line at row 1 is\nonly 10 characters long, and it would be clipped to (1, 10)",
          "arguments": [
            {
              "name": "position",
              "description": "A {Point} or point-compatible {Array}.",
              "type": "Point",
              "isOptional": false
            }
          ],
          "returnValues": [
            {
              "type": "Point",
              "description": "Returns a new {Point} if the given position is invalid, otherwise returns\nthe given position."
            }
          ]
        },
        {
          "name": "save",
          "sectionName": "Buffer Operations",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/text-buffer.coffee#L1619",
          "visibility": "Public",
          "summary": "Save the buffer.",
          "description": "Save the buffer.",
          "returnValues": [
            {
              "type": "Promise",
              "description": "Returns a {Promise} that resolves when the save has completed."
            }
          ]
        },
        {
          "name": "saveAs",
          "sectionName": "Buffer Operations",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/text-buffer.coffee#L1627",
          "visibility": "Public",
          "summary": "Save the buffer at a specific path.",
          "description": "Save the buffer at a specific path.",
          "arguments": [
            {
              "name": "filePath",
              "description": "The path to save at.",
              "type": null,
              "isOptional": false
            }
          ],
          "returnValues": [
            {
              "type": "Promise",
              "description": "Returns a {Promise} that resolves when the save has completed."
            }
          ]
        },
        {
          "name": "reload",
          "sectionName": "Buffer Operations",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/text-buffer.coffee#L1675",
          "visibility": "Public",
          "summary": "Reload the file's content from disk.",
          "description": "Reload the file's content from disk.",
          "returnValues": [
            {
              "type": "Promise",
              "description": "Returns a {Promise} that resolves when the load is complete."
            }
          ]
        },
        {
          "name": "loadSync",
          "sectionName": "Private Utility Methods",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/text-buffer.coffee#L1699",
          "visibility": "Public",
          "summary": "Create a new buffer backed by the given file path. For better\nperformance, use {TextBuffer.load} instead.",
          "description": "Create a new buffer backed by the given file path. For better\nperformance, use {TextBuffer.load} instead.",
          "arguments": [
            {
              "name": "filePath",
              "description": "The {String} file path.",
              "type": "String",
              "isOptional": false
            },
            {
              "children": [
                {
                  "name": "encoding",
                  "description": "{String} The file's encoding.",
                  "type": "String",
                  "isOptional": true
                },
                {
                  "name": "shouldDestroyOnFileDelete",
                  "description": "A {Function} that returns a {Boolean} indicating whether the buffer should be destroyed if its file is deleted.",
                  "type": "Function",
                  "isOptional": true
                }
              ],
              "name": "params",
              "description": "An {Object} with the following properties:",
              "type": "Object",
              "isOptional": false
            }
          ],
          "returnValues": [
            {
              "type": "TextBuffer",
              "description": "Returns a {TextBuffer} instance."
            }
          ]
        },
        {
          "name": "load",
          "sectionName": "Private Utility Methods",
          "srcUrl": "https://github.com/atom/text-buffer/blob/v13.8.5/src/text-buffer.coffee#L1723",
          "visibility": "Public",
          "summary": "Create a new buffer backed by the given file path.",
          "description": "Create a new buffer backed by the given file path.",
          "arguments": [
            {
              "name": "source",
              "description": "Either a {String} path to a local file or (experimentally) a file {Object} as described by the {::setFile} method.",
              "type": "String",
              "isOptional": false
            },
            {
              "children": [
                {
                  "name": "encoding",
                  "description": "{String} The file's encoding.",
                  "type": "String",
                  "isOptional": true
                },
                {
                  "name": "shouldDestroyOnFileDelete",
                  "description": "A {Function} that returns a {Boolean} indicating whether the buffer should be destroyed if its file is deleted.",
                  "type": "Function",
                  "isOptional": true
                }
              ],
              "name": "params",
              "description": "An {Object} with the following properties:",
              "type": "Object",
              "isOptional": false
            }
          ],
          "returnValues": [
            {
              "type": "Promise",
              "description": "Returns a {Promise} that resolves with a {TextBuffer} instance."
            }
          ]
        }
      ],
      "classProperties": [],
      "instanceProperties": [],
      "visibility": "Extended",
      "summary": "A mutable text container with undo/redo support and the ability to\nannotate logical regions in the text.",
      "description": "A mutable text container with undo/redo support and the ability to\nannotate logical regions in the text.\n\n## Observing Changes\n\nYou can observe changes in a {TextBuffer} using methods like {::onDidChange},\n{::onDidStopChanging}, and {::getChangesSinceCheckpoint}. These methods report\naggregated buffer updates as arrays of change objects containing the following\nfields: `oldRange`, `newRange`, `oldText`, and `newText`. The `oldText`,\n`newText`, and `newRange` fields are self-explanatory, but the interepretation\nof `oldRange` is more nuanced:\n\nThe reported `oldRange` is the range of the replaced text in the original\ncontents of the buffer *irrespective of the spatial impact of any other\nreported change*. So, for example, if you wanted to apply all the changes made\nin a transaction to a clone of the observed buffer, the easiest approach would\nbe to apply the changes in reverse:\n\n```js\nbuffer1.onDidChange(({changes}) => {\n  for (const {oldRange, newText} of changes.reverse()) {\n    buffer2.setTextInRange(oldRange, newText)\n  }\n})\n```\n\nIf you needed to apply the changes in the forwards order, you would need to\nincorporate the impact of preceding changes into the range passed to\n{::setTextInRange}, as follows:\n\n```js\nbuffer1.onDidChange(({changes}) => {\n  for (const {oldRange, newRange, newText} of changes) {\n    const rangeToReplace = Range(\n      newRange.start,\n      newRange.start.traverse(oldRange.getExtent())\n    )\n    buffer2.setTextInRange(rangeToReplace, newText)\n  }\n})\n```"
    }
  }
}