function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

const crypto = require('crypto');
const levelup = require('levelup');

module.exports = class TransformCache {
  constructor(filePath, invalidationKey) {
    this.filePath = filePath;
    this.invalidationKey = invalidationKey;
    this.db = null;
    this.usedKeys = new Set();
  }

  loadOrCreate() {
    var _this = this;

    return _asyncToGenerator(function* () {
      yield _this._initialize();
      const oldKey = yield _this._get('invalidation-key');
      const newKey = crypto.createHash('sha1').update(_this.invalidationKey).digest('hex');
      if (oldKey !== newKey) {
        const keys = yield _this._allKeys();
        const deleteOperations = Array.from(keys).map(function (key) {
          return { key, type: 'del' };
        });
        yield _this._batch(deleteOperations);
        yield _this._put('invalidation-key', newKey);
      }
    })();
  }

  dispose() {
    return new Promise((resolve, reject) => {
      this.db.close(error => {
        if (error) {
          reject(error);
        } else {
          resolve();
        }
      });
    });
  }

  put({ filePath, original, transformed, requires }) {
    var _this2 = this;

    return _asyncToGenerator(function* () {
      const key = crypto.createHash('sha1').update(original).digest('hex');
      yield _this2._put(filePath + ':' + key + ':source', transformed);
      yield _this2._put(filePath + ':' + key + ':requires', JSON.stringify(requires));
    })();
  }

  get({ filePath, content }) {
    var _this3 = this;

    return _asyncToGenerator(function* () {
      const key = crypto.createHash('sha1').update(content).digest('hex');
      const source = yield _this3._get(filePath + ':' + key + ':source');
      const requires = yield _this3._get(filePath + ':' + key + ':requires');
      if (source && requires) {
        return { source, requires: JSON.parse(requires) };
      } else {
        return null;
      }
    })();
  }

  deleteUnusedEntries() {
    var _this4 = this;

    return _asyncToGenerator(function* () {
      const unusedKeys = yield _this4._allKeys();
      for (const key of _this4.usedKeys) {
        unusedKeys.delete(key);
      }

      const deleteOperations = Array.from(unusedKeys).map(function (key) {
        return { key, type: 'del' };
      });
      yield _this4._batch(deleteOperations);
    })();
  }

  _initialize() {
    return new Promise((resolve, reject) => {
      levelup(this.filePath, {}, (error, db) => {
        if (error) {
          reject(error);
        } else {
          this.db = db;
          resolve();
        }
      });
    });
  }

  _put(key, value) {
    return new Promise((resolve, reject) => {
      this.db.put(key, value, {}, error => {
        if (error) {
          reject(error);
        } else {
          this.usedKeys.add(key);
          resolve();
        }
      });
    });
  }

  _get(key) {
    return new Promise((resolve, reject) => {
      this.db.get(key, {}, (error, value) => {
        if (error) {
          if (error.notFound) {
            resolve(null);
          } else {
            reject(error);
          }
        } else {
          this.usedKeys.add(key);
          resolve(value);
        }
      });
    });
  }

  _allKeys() {
    return new Promise((resolve, reject) => {
      const keys = new Set();
      const stream = this.db.createKeyStream();
      stream.on('data', key => {
        keys.add(key);
      });
      stream.on('error', error => {
        reject(error);
      });
      stream.on('close', () => {
        resolve(keys);
      });
    });
  }

  _batch(operations) {
    return new Promise((resolve, reject) => {
      this.db.batch(operations, {}, error => {
        if (error) {
          reject(error);
        } else {
          resolve();
        }
      });
    });
  }
};